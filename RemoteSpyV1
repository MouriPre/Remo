-- UI Library Base
local UILibrary = {}

-- Constants
local THEME = {
    Background = Color3.fromRGB(25, 25, 25),
    Accent = Color3.fromRGB(0, 170, 255), 
    LightContrast = Color3.fromRGB(35, 35, 35),
    DarkContrast = Color3.fromRGB(20, 20, 20),
    TextColor = Color3.fromRGB(255, 255, 255),
    PlaceholderColor = Color3.fromRGB(178, 178, 178)
}

local TEXT_SIZE = {
    Title = 20,
    Subtitle = 16,
    Regular = 14,
    Small = 12
}

-- Base Window
function UILibrary:CreateWindow(title)
    -- Main GUI
    local GUI = Instance.new("ScreenGui")
    GUI.Name = "RemoteSpy"
    GUI.ResetOnSpawn = false
    GUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    -- Main Frame
    local MainFrame = Instance.new("Frame")
    MainFrame.Name = "MainFrame"
    MainFrame.Size = UDim2.new(0, 650, 0, 400)
    MainFrame.Position = UDim2.new(0.5, -325, 0.5, -200)
    MainFrame.BackgroundColor3 = THEME.Background
    MainFrame.BorderSizePixel = 0
    MainFrame.Parent = GUI
    
    -- Make draggable
    local UserInputService = game:GetService("UserInputService")
    local dragging
    local dragInput
    local dragStart
    local startPos
    
    local function updateDrag(input)
        local delta = input.Position - dragStart
        MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
    
    MainFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = MainFrame.Position
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    
    MainFrame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            dragInput = input
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            updateDrag(input)
        end
    end)
    
    -- Rounded corners
    local Corner = Instance.new("UICorner")
    Corner.CornerRadius = UDim.new(0, 6)
    Corner.Parent = MainFrame
    
    -- Title Bar
    local TitleBar = Instance.new("Frame")
    TitleBar.Name = "TitleBar"
    TitleBar.Size = UDim2.new(1, 0, 0, 30)
    TitleBar.BackgroundColor3 = THEME.DarkContrast
    TitleBar.BorderSizePixel = 0
    TitleBar.Parent = MainFrame
    
    local TitleCorner = Instance.new("UICorner")
    TitleCorner.CornerRadius = UDim.new(0, 6)
    TitleCorner.Parent = TitleBar
    
    -- Title
    local TitleText = Instance.new("TextLabel")
    TitleText.Name = "Title"
    TitleText.Size = UDim2.new(1, -30, 1, 0)
    TitleText.Position = UDim2.new(0, 10, 0, 0)
    TitleText.BackgroundTransparency = 1
    TitleText.Text = title
    TitleText.TextColor3 = THEME.TextColor
    TitleText.TextSize = TEXT_SIZE.Title
    TitleText.Font = Enum.Font.GothamBold
    TitleText.TextXAlignment = Enum.TextXAlignment.Left
    TitleText.Parent = TitleBar
    
    -- Close Button
    local CloseButton = Instance.new("TextButton")
    CloseButton.Name = "CloseButton"
    CloseButton.Size = UDim2.new(0, 24, 0, 24)
    CloseButton.Position = UDim2.new(1, -27, 0, 3)
    CloseButton.BackgroundColor3 = THEME.Background
    CloseButton.Text = "×"
    CloseButton.TextColor3 = THEME.TextColor
    CloseButton.TextSize = 24
    CloseButton.Font = Enum.Font.GothamSemibold
    CloseButton.Parent = TitleBar
    
    local CloseCorner = Instance.new("UICorner")
    CloseCorner.CornerRadius = UDim.new(0, 4)
    CloseCorner.Parent = CloseButton
    
    CloseButton.MouseButton1Click:Connect(function()
        GUI:Destroy()
    end)
    
    -- Container for Tabs
    local TabContainer = Instance.new("Frame")
    TabContainer.Name = "TabContainer"
    TabContainer.Size = UDim2.new(0, 120, 1, -30)
    TabContainer.Position = UDim2.new(0, 0, 0, 30)
    TabContainer.BackgroundColor3 = THEME.DarkContrast
    TabContainer.BorderSizePixel = 0
    TabContainer.Parent = MainFrame
    
    -- Container for Tab Content
    local ContentContainer = Instance.new("Frame")
    ContentContainer.Name = "ContentContainer"
    ContentContainer.Size = UDim2.new(1, -120, 1, -30)
    ContentContainer.Position = UDim2.new(0, 120, 0, 30)
    ContentContainer.BackgroundColor3 = THEME.LightContrast
    ContentContainer.BorderSizePixel = 0
    ContentContainer.Parent = MainFrame
    
    local ContentCorner = Instance.new("UICorner")
    ContentCorner.CornerRadius = UDim.new(0, 6)
    ContentCorner.Parent = ContentContainer
    
    -- Store references and state
    local window = {
        GUI = GUI,
        MainFrame = MainFrame,
        TabContainer = TabContainer,
        ContentContainer = ContentContainer,
        Tabs = {},
        CurrentTab = nil
    }
    
    setmetatable(window, self)
    self.__index = self
    
    return window
end

-- Create new instance of library
local RemoteSpyUI = UILibrary:CreateWindow("Remote Spy")

-- Add to CoreGui
if syn then
    syn.protect_gui(RemoteSpyUI.GUI)
    RemoteSpyUI.GUI.Parent = game:GetService("CoreGui")
else
    RemoteSpyUI.GUI.Parent = game:GetService("CoreGui")
end
-- Thêm vào phần UI Library

-- Tab System
function UILibrary:CreateTab(name, icon)
    -- Tab Button
    local TabButton = Instance.new("TextButton")
    TabButton.Name = name.."Tab"
    TabButton.Size = UDim2.new(1, 0, 0, 32)
    TabButton.BackgroundColor3 = THEME.DarkContrast
    TabButton.BorderSizePixel = 0
    TabButton.Text = ""
    TabButton.AutoButtonColor = false
    
    -- Icon (if provided)
    if icon then
        local Icon = Instance.new("ImageLabel")
        Icon.Name = "Icon"
        Icon.Size = UDim2.new(0, 16, 0, 16)
        Icon.Position = UDim2.new(0, 10, 0.5, -8)
        Icon.BackgroundTransparency = 1
        Icon.Image = icon
        Icon.Parent = TabButton
    end
    
    -- Tab Name
    local TabName = Instance.new("TextLabel")
    TabName.Name = "TabName"
    TabName.Size = UDim2.new(1, -40, 1, 0)
    TabName.Position = UDim2.new(0, 35, 0, 0)
    TabName.BackgroundTransparency = 1
    TabName.Text = name
    TabName.TextColor3 = THEME.TextColor
    TabName.TextSize = TEXT_SIZE.Regular
    TabName.Font = Enum.Font.GothamSemibold
    TabName.TextXAlignment = Enum.TextXAlignment.Left
    TabName.Parent = TabButton
    
    -- Selection Indicator
    local SelectionIndicator = Instance.new("Frame")
    SelectionIndicator.Name = "SelectionIndicator"
    SelectionIndicator.Size = UDim2.new(0, 2, 1, 0)
    SelectionIndicator.BackgroundColor3 = THEME.Accent
    SelectionIndicator.BorderSizePixel = 0
    SelectionIndicator.Visible = false
    SelectionIndicator.Parent = TabButton
    
    -- Tab Content
    local TabContent = Instance.new("ScrollingFrame")
    TabContent.Name = name.."Content"
    TabContent.Size = UDim2.new(1, -20, 1, -20)
    TabContent.Position = UDim2.new(0, 10, 0, 10)
    TabContent.BackgroundTransparency = 1
    TabContent.BorderSizePixel = 0
    TabContent.ScrollBarThickness = 2
    TabContent.ScrollBarImageColor3 = THEME.Accent
    TabContent.Visible = false
    
    -- Auto-size content
    local UIListLayout = Instance.new("UIListLayout")
    UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    UIListLayout.Padding = UDim.new(0, 5)
    UIListLayout.Parent = TabContent
    
    UIListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        TabContent.CanvasSize = UDim2.new(0, 0, 0, UIListLayout.AbsoluteContentSize.Y + 20)
    end)
    
    -- Position tabs vertically
    local tabCount = #self.TabContainer:GetChildren()
    TabButton.Position = UDim2.new(0, 0, 0, tabCount * 32)
    
    TabButton.Parent = self.TabContainer
    TabContent.Parent = self.ContentContainer
    
    -- Tab click handler
    TabButton.MouseButton1Click:Connect(function()
        self:SelectTab(name)
    end)
    
    -- Store tab data
    local tab = {
        Button = TabButton,
        Content = TabContent,
        Indicator = SelectionIndicator
    }
    
    self.Tabs[name] = tab
    
    -- Select first tab by default
    if tabCount == 0 then
        self:SelectTab(name)
    end
    
    return tab
end

function UILibrary:SelectTab(name)
    -- Deselect current tab
    if self.CurrentTab then
        self.Tabs[self.CurrentTab].Content.Visible = false
        self.Tabs[self.CurrentTab].Button.BackgroundColor3 = THEME.DarkContrast
        self.Tabs[self.CurrentTab].Indicator.Visible = false
    end
    
    -- Select new tab
    self.CurrentTab = name
    self.Tabs[name].Content.Visible = true
    self.Tabs[name].Button.BackgroundColor3 = THEME.LightContrast
    self.Tabs[name].Indicator.Visible = true
end

-- UI Elements
function UILibrary:CreateSection(tab, title)
    local Section = Instance.new("Frame")
    Section.Name = title.."Section"
    Section.Size = UDim2.new(1, 0, 0, 30) -- Will be adjusted by UIListLayout
    Section.BackgroundColor3 = THEME.DarkContrast
    Section.BorderSizePixel = 0
    
    local Corner = Instance.new("UICorner")
    Corner.CornerRadius = UDim.new(0, 4)
    Corner.Parent = Section
    
    -- Section Title
    local Title = Instance.new("TextLabel")
    Title.Size = UDim2.new(1, -10, 0, 26)
    Title.Position = UDim2.new(0, 10, 0, 0)
    Title.BackgroundTransparency = 1
    Title.Text = title
    Title.TextColor3 = THEME.TextColor
    Title.TextSize = TEXT_SIZE.Subtitle
    Title.Font = Enum.Font.GothamBold
    Title.TextXAlignment = Enum.TextXAlignment.Left
    Title.Parent = Section
    
    -- Container for section content
    local Container = Instance.new("Frame")
    Container.Name = "Container"
    Container.Size = UDim2.new(1, -20, 0, 0) -- Will be adjusted by UIListLayout
    Container.Position = UDim2.new(0, 10, 0, 26)
    Container.BackgroundTransparency = 1
    Container.Parent = Section
    
    local UIListLayout = Instance.new("UIListLayout")
    UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    UIListLayout.Padding = UDim.new(0, 5)
    UIListLayout.Parent = Container
    
    -- Auto-size section based on content
    UIListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        Container.Size = UDim2.new(1, -20, 0, UIListLayout.AbsoluteContentSize.Y)
        Section.Size = UDim2.new(1, 0, 0, Container.Size.Y.Offset + 35)
    end)
    
    Section.Parent = self.Tabs[tab].Content
    
    return Container
end

function UILibrary:CreateButton(container, text, callback)
    local Button = Instance.new("TextButton")
    Button.Size = UDim2.new(1, 0, 0, 32)
    Button.BackgroundColor3 = THEME.LightContrast
    Button.Text = text
    Button.TextColor3 = THEME.TextColor
    Button.TextSize = TEXT_SIZE.Regular
    Button.Font = Enum.Font.GothamSemibold
    Button.AutoButtonColor = false
    
    local Corner = Instance.new("UICorner")
    Corner.CornerRadius = UDim.new(0, 4)
    Corner.Parent = Button
    
    -- Hover & Click Effects
    Button.MouseEnter:Connect(function()
        Button.BackgroundColor3 = THEME.Accent
    end)
    
    Button.MouseLeave:Connect(function()
        Button.BackgroundColor3 = THEME.LightContrast
    end)
    
    Button.MouseButton1Click:Connect(function()
        callback()
    end)
    
    Button.Parent = container
    return Button
end

function UILibrary:CreateToggle(container, text, default, callback)
    local Toggle = Instance.new("TextButton")
    Toggle.Size = UDim2.new(1, 0, 0, 32)
    Toggle.BackgroundColor3 = THEME.LightContrast
    Toggle.Text = ""
    Toggle.AutoButtonColor = false
    
    local Corner = Instance.new("UICorner")
    Corner.CornerRadius = UDim.new(0, 4)
    Corner.Parent = Toggle
    
    local Title = Instance.new("TextLabel")
    Title.Size = UDim2.new(1, -60, 1, 0)
    Title.Position = UDim2.new(0, 10, 0, 0)
    Title.BackgroundTransparency = 1
    Title.Text = text
    Title.TextColor3 = THEME.TextColor
    Title.TextSize = TEXT_SIZE.Regular
    Title.Font = Enum.Font.GothamSemibold
    Title.TextXAlignment = Enum.TextXAlignment.Left
    Title.Parent = Toggle
    
    -- Toggle Indicator
    local Indicator = Instance.new("Frame")
    Indicator.Size = UDim2.new(0, 40, 0, 20)
    Indicator.Position = UDim2.new(1, -50, 0.5, -10)
    Indicator.BackgroundColor3 = THEME.DarkContrast
    Indicator.Parent = Toggle
    
    local IndicatorCorner = Instance.new("UICorner")
    IndicatorCorner.CornerRadius = UDim.new(0, 10)
    IndicatorCorner.Parent = Indicator
    
    local Circle = Instance.new("Frame")
    Circle.Size = UDim2.new(0, 16, 0, 16)
    Circle.Position = UDim2.new(0, 2, 0.5, -8)
    Circle.BackgroundColor3 = THEME.TextColor
    Circle.Parent = Indicator
    
    local CircleCorner = Instance.new("UICorner")
    CircleCorner.CornerRadius = UDim.new(1, 0)
    CircleCorner.Parent = Circle
    
    local enabled = default or false
    
    local function updateVisual()
        if enabled then
            Circle:TweenPosition(UDim2.new(1, -18, 0.5, -8), "Out", "Sine", 0.2, true)
            Indicator.BackgroundColor3 = THEME.Accent
        else
            Circle:TweenPosition(UDim2.new(0, 2, 0.5, -8), "Out", "Sine", 0.2, true)
            Indicator.BackgroundColor3 = THEME.DarkContrast
        end
    end
    
    Toggle.MouseButton1Click:Connect(function()
        enabled = not enabled
        updateVisual()
        callback(enabled)
    end)
    
    updateVisual() -- Set initial state
    Toggle.Parent = container
    return Toggle
end
-- Thêm vào phần UI Elements

function UILibrary:CreateTextbox(container, placeholder, callback)
    local Textbox = Instance.new("Frame")
    Textbox.Size = UDim2.new(1, 0, 0, 32)
    Textbox.BackgroundColor3 = THEME.LightContrast
    
    local Corner = Instance.new("UICorner")
    Corner.CornerRadius = UDim.new(0, 4)
    Corner.Parent = Textbox
    
    local Input = Instance.new("TextBox")
    Input.Size = UDim2.new(1, -20, 1, -10)
    Input.Position = UDim2.new(0, 10, 0, 5)
    Input.BackgroundTransparency = 1
    Input.Text = ""
    Input.PlaceholderText = placeholder
    Input.PlaceholderColor3 = THEME.PlaceholderColor
    Input.TextColor3 = THEME.TextColor
    Input.TextSize = TEXT_SIZE.Regular
    Input.Font = Enum.Font.Gotham
    Input.ClearTextOnFocus = false
    Input.Parent = Textbox
    
    Input.FocusLost:Connect(function(enterPressed)
        if enterPressed then
            callback(Input.Text)
        end
    end)
    
    Textbox.Parent = container
    return Input
end

function UILibrary:CreateDropdown(container, text, options, callback)
    local Dropdown = Instance.new("Frame")
    Dropdown.Size = UDim2.new(1, 0, 0, 32)
    Dropdown.BackgroundColor3 = THEME.LightContrast
    
    local Corner = Instance.new("UICorner")
    Corner.CornerRadius = UDim.new(0, 4)
    Corner.Parent = Dropdown
    
    local Title = Instance.new("TextLabel")
    Title.Size = UDim2.new(1, -40, 1, 0)
    Title.Position = UDim2.new(0, 10, 0, 0)
    Title.BackgroundTransparency = 1
    Title.Text = text
    Title.TextColor3 = THEME.TextColor
    Title.TextSize = TEXT_SIZE.Regular
    Title.Font = Enum.Font.GothamSemibold
    Title.TextXAlignment = Enum.TextXAlignment.Left
    Title.Parent = Dropdown
    
    local Arrow = Instance.new("TextLabel")
    Arrow.Size = UDim2.new(0, 20, 1, 0)
    Arrow.Position = UDim2.new(1, -25, 0, 0)
    Arrow.BackgroundTransparency = 1
    Arrow.Text = "▼"
    Arrow.TextColor3 = THEME.TextColor
    Arrow.TextSize = TEXT_SIZE.Regular
    Arrow.Font = Enum.Font.GothamBold
    Arrow.Parent = Dropdown
    
    local OptionContainer = Instance.new("Frame")
    OptionContainer.Size = UDim2.new(1, 0, 0, 0)
    OptionContainer.Position = UDim2.new(0, 0, 1, 5)
    OptionContainer.BackgroundColor3 = THEME.LightContrast
    OptionContainer.BorderSizePixel = 0
    OptionContainer.ClipsDescendants = true
    OptionContainer.Visible = false
    OptionContainer.ZIndex = 2
    OptionContainer.Parent = Dropdown
    
    local OptionCorner = Instance.new("UICorner")
    OptionCorner.CornerRadius = UDim.new(0, 4)
    OptionCorner.Parent = OptionContainer
    
    local UIListLayout = Instance.new("UIListLayout")
    UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    UIListLayout.Parent = OptionContainer
    
    local selected = false
    local currentOption = nil
    
    local function createOption(option)
        local OptionButton = Instance.new("TextButton")
        OptionButton.Size = UDim2.new(1, 0, 0, 30)
        OptionButton.BackgroundTransparency = 1
        OptionButton.Text = option
        OptionButton.TextColor3 = THEME.TextColor
        OptionButton.TextSize = TEXT_SIZE.Regular
        OptionButton.Font = Enum.Font.Gotham
        OptionButton.ZIndex = 2
        OptionButton.Parent = OptionContainer
        
        OptionButton.MouseButton1Click:Connect(function()
            Title.Text = text .. ": " .. option
            currentOption = option
            OptionContainer.Visible = false
            Arrow.Text = "▼"
            selected = false
            callback(option)
        end)
        
        return OptionButton
    end
    
    -- Create all options
    for _, option in ipairs(options) do
        createOption(option)
    end
    
    -- Toggle dropdown
    Dropdown.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            selected = not selected
            OptionContainer.Visible = selected
            Arrow.Text = selected and "▲" or "▼"
            if selected then
                OptionContainer.Size = UDim2.new(1, 0, 0, #options * 30)
            end
        end
    end)
    
    Dropdown.Parent = container
    return Dropdown
end

-- Remote Spy Interface
function UILibrary:CreateRemoteSpyInterface()
    -- Create main tabs
    local remoteLogTab = self:CreateTab("Remote Log", "rbxassetid://4370341699")
    local settingsTab = self:CreateTab("Settings", "rbxassetid://4370337241")
    
    -- Remote Log Section
    local logSection = self:CreateSection("remoteLogTab", "Remote Calls")
    
    -- Create log container
    local LogContainer = Instance.new("ScrollingFrame")
    LogContainer.Name = "LogContainer"
    LogContainer.Size = UDim2.new(1, 0, 1, -45) -- Leave space for buttons
    LogContainer.BackgroundTransparency = 1
    LogContainer.BorderSizePixel = 0
    LogContainer.ScrollBarThickness = 2
    LogContainer.ScrollBarImageColor3 = THEME.Accent
    
    local UIListLayout = Instance.new("UIListLayout")
    UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    UIListLayout.Padding = UDim.new(0, 5)
    UIListLayout.Parent = LogContainer
    
    -- Auto-size content
    UIListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        LogContainer.CanvasSize = UDim2.new(0, 0, 0, UIListLayout.AbsoluteContentSize.Y + 5)
    end)
    
    LogContainer.Parent = logSection
    
    -- Control buttons
    local ButtonContainer = self:CreateSection("remoteLogTab", "Controls")
    
    self:CreateButton(ButtonContainer, "Clear Logs", function()
        for _, child in ipairs(LogContainer:GetChildren()) do
            if child:IsA("Frame") then
                child:Destroy()
            end
        end
    end)
    
    -- Settings Section
    local settingsSection = self:CreateSection("settingsTab", "Spy Settings")
    
    self:CreateToggle(settingsSection, "Log RemoteEvents", true, function(enabled)
        -- Toggle RemoteEvent logging
    end)
    
    self:CreateToggle(settingsSection, "Log RemoteFunctions", true, function(enabled)
        -- Toggle RemoteFunction logging
    end)
    
    self:CreateToggle(settingsSection, "Ignore Replicated", false, function(enabled)
        -- Toggle ignored replicated events
    end)
    
    -- Create function to add new log entry
    function self:AddLogEntry(remoteType, remoteName, args)
        local LogEntry = Instance.new("Frame")
        LogEntry.Size = UDim2.new(1, 0, 0, 40)
        LogEntry.BackgroundColor3 = THEME.DarkContrast
        
        local Corner = Instance.new("UICorner")
        Corner.CornerRadius = UDim.new(0, 4)
        Corner.Parent = LogEntry
        
        -- Remote type indicator
        local TypeIndicator = Instance.new("Frame")
        TypeIndicator.Size = UDim2.new(0, 4, 1, 0)
        TypeIndicator.BackgroundColor3 = remoteType == "RemoteEvent" and Color3.fromRGB(255, 133, 0) or Color3.fromRGB(0, 255, 140)
        TypeIndicator.BorderSizePixel = 0
        TypeIndicator.Parent = LogEntry
        
        local TypeCorner = Instance.new("UICorner")
        TypeCorner.CornerRadius = UDim.new(0, 4)
        TypeCorner.Parent = TypeIndicator
        
        -- Remote name
        local Name = Instance.new("TextLabel")
        Name.Size = UDim2.new(1, -20, 0, 20)
        Name.Position = UDim2.new(0, 10, 0, 5)
        Name.BackgroundTransparency = 1
        Name.Text = remoteName
        Name.TextColor3 = THEME.TextColor
        Name.TextSize = TEXT_SIZE.Regular
        Name.Font = Enum.Font.GothamSemibold
        Name.TextXAlignment = Enum.TextXAlignment.Left
        Name.Parent = LogEntry
        
        -- Arguments preview
        local Args = Instance.new("TextLabel")
        Args.Size = UDim2.new(1, -20, 0, 20)
        Args.Position = UDim2.new(0, 10, 0, 20)
        Args.BackgroundTransparency = 1
        Args.Text = "Args: " .. table.concat(args, ", ")
        Args.TextColor3 = THEME.PlaceholderColor
        Args.TextSize = TEXT_SIZE.Small
        Args.Font = Enum.Font.Gotham
        Args.TextXAlignment = Enum.TextXAlignment.Left
        Args.Parent = LogEntry
        
        LogEntry.Parent = LogContainer
        
        -- Auto scroll to bottom
        LogContainer.CanvasPosition = Vector2.new(0, LogContainer.CanvasSize.Y.Offset)
    end
    
    return self
end
-- Context Menu System
function UILibrary:CreateContextMenu()
    local ContextMenu = Instance.new("Frame")
    ContextMenu.Name = "ContextMenu"
    ContextMenu.Size = UDim2.new(0, 200, 0, 0)
    ContextMenu.BackgroundColor3 = THEME.DarkContrast
    ContextMenu.BorderSizePixel = 0
    ContextMenu.Visible = false
    ContextMenu.ZIndex = 100
    
    local Corner = Instance.new("UICorner")
    Corner.CornerRadius = UDim.new(0, 4)
    Corner.Parent = ContextMenu
    
    local UIListLayout = Instance.new("UIListLayout")
    UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    UIListLayout.Parent = ContextMenu
    
    -- Auto-size based on content
    UIListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        ContextMenu.Size = UDim2.new(0, 200, 0, UIListLayout.AbsoluteContentSize.Y)
    end)
    
    function ContextMenu:AddOption(text, callback)
        local Option = Instance.new("TextButton")
        Option.Size = UDim2.new(1, 0, 0, 30)
        Option.BackgroundTransparency = 1
        Option.Text = text
        Option.TextColor3 = THEME.TextColor
        Option.TextSize = TEXT_SIZE.Regular
        Option.Font = Enum.Font.Gotham
        Option.ZIndex = 100
        Option.Parent = ContextMenu
        
        Option.MouseEnter:Connect(function()
            Option.BackgroundTransparency = 0.9
        end)
        
        Option.MouseLeave:Connect(function()
            Option.BackgroundTransparency = 1
        end)
        
        Option.MouseButton1Click:Connect(function()
            ContextMenu.Visible = false
            callback()
        end)
    end
    
    ContextMenu.Parent = self.GUI
    return ContextMenu
end

-- Detailed View Window
function UILibrary:CreateDetailedView()
    local DetailedView = Instance.new("Frame")
    DetailedView.Name = "DetailedView"
    DetailedView.Size = UDim2.new(0, 400, 0, 500)
    DetailedView.Position = UDim2.new(0.5, -200, 0.5, -250)
    DetailedView.BackgroundColor3 = THEME.Background
    DetailedView.BorderSizePixel = 0
    DetailedView.Visible = false
    DetailedView.ZIndex = 50
    
    local Corner = Instance.new("UICorner")
    Corner.CornerRadius = UDim.new(0, 6)
    Corner.Parent = DetailedView
    
    -- Header
    local Header = Instance.new("Frame")
    Header.Size = UDim2.new(1, 0, 0, 40)
    Header.BackgroundColor3 = THEME.DarkContrast
    Header.ZIndex = 51
    Header.Parent = DetailedView
    
    local HeaderCorner = Instance.new("UICorner")
    HeaderCorner.CornerRadius = UDim.new(0, 6)
    HeaderCorner.Parent = Header
    
    local Title = Instance.new("TextLabel")
    Title.Size = UDim2.new(1, -40, 1, 0)
    Title.Position = UDim2.new(0, 10, 0, 0)
    Title.BackgroundTransparency = 1
    Title.Text = "Remote Details"
    Title.TextColor3 = THEME.TextColor
    Title.TextSize = TEXT_SIZE.Title
    Title.Font = Enum.Font.GothamBold
    Title.TextXAlignment = Enum.TextXAlignment.Left
    Title.ZIndex = 51
    Title.Parent = Header
    
    local CloseButton = Instance.new("TextButton")
    CloseButton.Size = UDim2.new(0, 30, 0, 30)
    CloseButton.Position = UDim2.new(1, -35, 0, 5)
    CloseButton.BackgroundTransparency = 1
    CloseButton.Text = "×"
    CloseButton.TextColor3 = THEME.TextColor
    CloseButton.TextSize = 24
    CloseButton.Font = Enum.Font.GothamBold
    CloseButton.ZIndex = 51
    CloseButton.Parent = Header
    
    CloseButton.MouseButton1Click:Connect(function()
        DetailedView.Visible = false
    end)
    
    -- Content
    local Content = Instance.new("ScrollingFrame")
    Content.Size = UDim2.new(1, -20, 1, -50)
    Content.Position = UDim2.new(0, 10, 0, 45)
    Content.BackgroundTransparency = 1
    Content.BorderSizePixel = 0
    Content.ScrollBarThickness = 2
    Content.ScrollBarImageColor3 = THEME.Accent
    Content.ZIndex = 51
    Content.Parent = DetailedView
    
    local UIListLayout = Instance.new("UIListLayout")
    UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    UIListLayout.Padding = UDim.new(0, 10)
    UIListLayout.Parent = Content
    
    -- Auto-size content
    UIListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        Content.CanvasSize = UDim2.new(0, 0, 0, UIListLayout.AbsoluteContentSize.Y + 20)
    end)
    
    function DetailedView:SetRemoteInfo(remoteType, remoteName, args, source)
        Title.Text = string.format("%s: %s", remoteType, remoteName)
        
        -- Clear previous content
        for _, child in ipairs(Content:GetChildren()) do
            if child:IsA("Frame") then
                child:Destroy()
            end
        end
        
        -- Add info sections
        local function addSection(title, content)
            local Section = Instance.new("Frame")
            Section.Size = UDim2.new(1, 0, 0, 0) -- Auto-sized
            Section.BackgroundColor3 = THEME.DarkContrast
            Section.ZIndex = 51
            
            local SectionCorner = Instance.new("UICorner")
            SectionCorner.CornerRadius = UDim.new(0, 4)
            SectionCorner.Parent = Section
            
            local SectionTitle = Instance.new("TextLabel")
            SectionTitle.Size = UDim2.new(1, -20, 0, 30)
            SectionTitle.Position = UDim2.new(0, 10, 0, 0)
            SectionTitle.BackgroundTransparency = 1
            SectionTitle.Text = title
            SectionTitle.TextColor3 = THEME.TextColor
            SectionTitle.TextSize = TEXT_SIZE.Regular
            SectionTitle.Font = Enum.Font.GothamBold
            SectionTitle.TextXAlignment = Enum.TextXAlignment.Left
            SectionTitle.ZIndex = 51
            SectionTitle.Parent = Section
            
            local ContentLabel = Instance.new("TextLabel")
            ContentLabel.Size = UDim2.new(1, -20, 0, 0)
            ContentLabel.Position = UDim2.new(0, 10, 0, 30)
            ContentLabel.BackgroundTransparency = 1
            ContentLabel.Text = content
            ContentLabel.TextColor3 = THEME.TextColor
            ContentLabel.TextSize = TEXT_SIZE.Regular
            ContentLabel.Font = Enum.Font.Gotham
            ContentLabel.TextXAlignment = Enum.TextXAlignment.Left
            ContentLabel.TextWrapped = true
            ContentLabel.ZIndex = 51
            ContentLabel.Parent = Section
            
            -- Auto-size based on text content
            local textSize = game:GetService("TextService"):GetTextSize(
                content,
                TEXT_SIZE.Regular,
                Enum.Font.Gotham,
                Vector2.new(Section.AbsoluteSize.X - 20, math.huge)
            )
            
            ContentLabel.Size = UDim2.new(1, -20, 0, textSize.Y)
            Section.Size = UDim2.new(1, 0, 0, textSize.Y + 40)
            Section.Parent = Content
        end
        
        -- Add sections with remote information
        addSection("Remote Path", remoteName)
        addSection("Arguments", UILibrary:PrettyPrint(args))
        if source then
            addSection("Source Script", source)
        end
    end
    
    DetailedView.Parent = self.GUI
    return DetailedView
end

-- Code Generation
function UILibrary:GenerateRemoteCode(remoteType, remotePath, args)
    local code = string.format([[
local remote = game:GetService("ReplicatedStorage"):WaitForChild("%s")

-- Generated remote call
local args = %s

%s]], 
        remotePath,
        UILibrary:PrettyPrint(args),
        remoteType == "RemoteEvent" and "remote:FireServer(unpack(args))" or "local result = remote:InvokeServer(unpack(args))"
    )
    
    return code
end

-- Pretty Print for Lua tables
function UILibrary:PrettyPrint(tbl, indent)
    if type(tbl) ~= "table" then
        return tostring(tbl)
    end
    
    indent = indent or "    "
    local result = "{\n"
    
    for k, v in pairs(tbl) do
        result = result .. indent
        
        -- Handle key
        if type(k) == "string" then
            result = result .. string.format("[%q] = ", k)
        else
            result = result .. string.format("[%s] = ", tostring(k))
        end
        
        -- Handle value
        if type(v) == "table" then
            result = result .. UILibrary:PrettyPrint(v, indent .. "    ")
        elseif type(v) == "string" then
            result = result .. string.format("%q", v)
        else
            result = result .. tostring(v)
        end
        
        result = result .. ",\n"
    end
    
    result = result .. string.sub(indent, 1, -5) .. "}"
    return result
end

-- Enhance log entry with context menu and detailed view
function UILibrary:EnhanceLogEntry(logEntry, remoteType, remoteName, args, source)
    -- Create context menu
    local contextMenu = self:CreateContextMenu()
    
    contextMenu:AddOption("Copy Remote Path", function()
        setclipboard(remoteName)
    end)
    
    contextMenu:AddOption("Copy Arguments", function()
        setclipboard(UILibrary:PrettyPrint(args))
    end)
    
    contextMenu:AddOption("Generate Code", function()
        setclipboard(self:GenerateRemoteCode(remoteType, remoteName, args))
    end)
    
    contextMenu:AddOption("View Details", function()
        self.DetailedView:SetRemoteInfo(remoteType, remoteName, args, source)
        self.DetailedView.Visible = true
    end)
    
    -- Show context menu on right click
    logEntry.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton2 then
            contextMenu.Position = UDim2.new(0, input.Position.X, 0, input.Position.Y)
            contextMenu.Visible = true
        end
    end)
    
    -- Hide context menu when clicking elsewhere
    self.GUI.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            contextMenu.Visible = false
        end
    end)
end
-- Filtering and Search System
function UILibrary:CreateFilterSystem(container)
    local FilterSystem = Instance.new("Frame")
    FilterSystem.Size = UDim2.new(1, 0, 0, 35)
    FilterSystem.BackgroundTransparency = 1
    
    -- Search bar
    local SearchBar = self:CreateTextbox(FilterSystem, "Search remotes...")
    SearchBar.Size = UDim2.new(0.5, -10, 1, 0)
    SearchBar.Position = UDim2.new(0, 0, 0, 0)
    
    -- Filter dropdown
    local filterOptions = {
        "All",
        "RemoteEvents",
        "RemoteFunctions",
        "Blocked",
        "Flagged"
    }
    
    local FilterDropdown = self:CreateDropdown(FilterSystem, "Filter", filterOptions, function(option)
        self:ApplyFilters(SearchBar.Text, option)
    end)
    FilterDropdown.Size = UDim2.new(0.5, -10, 1, 0)
    FilterDropdown.Position = UDim2.new(0.5, 10, 0, 0)
    
    -- Search functionality
    local debounce = false
    SearchBar.Changed:Connect(function(property)
        if property == "Text" then
            if debounce then return end
            debounce = true
            
            wait(0.3) -- Debounce delay
            self:ApplyFilters(SearchBar.Text, FilterDropdown.CurrentOption)
            
            debounce = false
        end
    end)
    
    FilterSystem.Parent = container
    return FilterSystem
end

-- Apply filters to log entries
function UILibrary:ApplyFilters(searchText, filterType)
    for _, logEntry in ipairs(self.LogContainer:GetChildren()) do
        if logEntry:IsA("Frame") then
            local remoteName = logEntry:FindFirstChild("Name").Text
            local remoteType = logEntry:GetAttribute("RemoteType")
            local isFlagged = logEntry:GetAttribute("Flagged")
            local isBlocked = logEntry:GetAttribute("Blocked")
            
            local matchesSearch = string.find(string.lower(remoteName), string.lower(searchText), 1, true)
            local matchesFilter = false
            
            if filterType == "All" then
                matchesFilter = true
            elseif filterType == "RemoteEvents" then
                matchesFilter = remoteType == "RemoteEvent"
            elseif filterType == "RemoteFunctions" then
                matchesFilter = remoteType == "RemoteFunction"
            elseif filterType == "Blocked" then
                matchesFilter = isBlocked
            elseif filterType == "Flagged" then
                matchesFilter = isFlagged
            end
            
            logEntry.Visible = matchesSearch and matchesFilter
        end
    end
end

-- Remote Call History System
function UILibrary:CreateHistorySystem()
    self.History = {}
    self.HistoryIndex = 0
    self.MaxHistory = 1000 -- Maximum number of entries to keep
    
    function self:AddToHistory(remoteType, remoteName, args, source)
        table.insert(self.History, {
            timestamp = os.time(),
            remoteType = remoteType,
            remoteName = remoteName,
            args = args,
            source = source
        })
        
        -- Remove oldest entry if exceeding max history
        if #self.History > self.MaxHistory then
            table.remove(self.History, 1)
        end
        
        self:UpdateHistoryStats()
    end
    
    -- Create history window
    local HistoryWindow = Instance.new("Frame")
    HistoryWindow.Name = "HistoryWindow"
    HistoryWindow.Size = UDim2.new(0, 300, 1, 0)
    HistoryWindow.Position = UDim2.new(1, 10, 0, 0)
    HistoryWindow.BackgroundColor3 = THEME.Background
    HistoryWindow.BorderSizePixel = 0
    HistoryWindow.Visible = false
    
    local Corner = Instance.new("UICorner")
    Corner.CornerRadius = UDim.new(0, 6)
    Corner.Parent = HistoryWindow
    
    -- History header
    local Header = Instance.new("Frame")
    Header.Size = UDim2.new(1, 0, 0, 40)
    Header.BackgroundColor3 = THEME.DarkContrast
    Header.Parent = HistoryWindow
    
    local HeaderCorner = Instance.new("UICorner")
    HeaderCorner.CornerRadius = UDim.new(0, 6)
    HeaderCorner.Parent = Header
    
    local Title = Instance.new("TextLabel")
    Title.Size = UDim2.new(1, -40, 1, 0)
    Title.Position = UDim2.new(0, 10, 0, 0)
    Title.BackgroundTransparency = 1
    Title.Text = "Remote Call History"
    Title.TextColor3 = THEME.TextColor
    Title.TextSize = TEXT_SIZE.Title
    Title.Font = Enum.Font.GothamBold
    Title.TextXAlignment = Enum.TextXAlignment.Left
    Title.Parent = Header
    
    -- Stats container
    local StatsContainer = Instance.new("Frame")
    StatsContainer.Size = UDim2.new(1, -20, 0, 60)
    StatsContainer.Position = UDim2.new(0, 10, 0, 50)
    StatsContainer.BackgroundColor3 = THEME.LightContrast
    StatsContainer.Parent = HistoryWindow
    
    local StatsCorner = Instance.new("UICorner")
    StatsCorner.CornerRadius = UDim.new(0, 4)
    StatsCorner.Parent = StatsContainer
    
    local StatsLayout = Instance.new("UIListLayout")
    StatsLayout.FillDirection = Enum.FillDirection.Horizontal
    StatsLayout.Padding = UDim.new(0, 10)
    StatsLayout.VerticalAlignment = Enum.VerticalAlignment.Center
    StatsLayout.Parent = StatsContainer
    
    -- Create stat labels
    local function createStat(title)
        local Stat = Instance.new("Frame")
        Stat.Size = UDim2.new(0.333, -7, 0, 40)
        Stat.BackgroundTransparency = 1
        
        local Title = Instance.new("TextLabel")
        Title.Size = UDim2.new(1, 0, 0, 20)
        Title.BackgroundTransparency = 1
        Title.Text = title
        Title.TextColor3 = THEME.PlaceholderColor
        Title.TextSize = TEXT_SIZE.Small
        Title.Font = Enum.Font.Gotham
        Title.Parent = Stat
        
        local Value = Instance.new("TextLabel")
        Value.Size = UDim2.new(1, 0, 0, 20)
        Value.Position = UDim2.new(0, 0, 0, 20)
        Value.BackgroundTransparency = 1
        Value.Text = "0"
        Value.TextColor3 = THEME.TextColor
        Value.TextSize = TEXT_SIZE.Regular
        Value.Font = Enum.Font.GothamBold
        Value.Parent = Stat
        
        Stat.Parent = StatsContainer
        return Value
    end
    
    local totalCalls = createStat("Total Calls")
    local eventsCount = createStat("Remote Events")
    local functionsCount = createStat("Remote Functions")
    
    -- History list
    local HistoryList = Instance.new("ScrollingFrame")
    HistoryList.Size = UDim2.new(1, -20, 1, -120)
    HistoryList.Position = UDim2.new(0, 10, 0, 120)
    HistoryList.BackgroundTransparency = 1
    HistoryList.BorderSizePixel = 0
    HistoryList.ScrollBarThickness = 2
    HistoryList.ScrollBarImageColor3 = THEME.Accent
    HistoryList.Parent = HistoryWindow
    
    local ListLayout = Instance.new("UIListLayout")
    ListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    ListLayout.Padding = UDim.new(0, 5)
    ListLayout.Parent = HistoryList
    
    -- Update history stats
    function self:UpdateHistoryStats()
        local events = 0
        local functions = 0
        
        for _, entry in ipairs(self.History) do
            if entry.remoteType == "RemoteEvent" then
                events = events + 1
            else
                functions = functions + 1
            end
        end
        
        totalCalls.Text = tostring(#self.History)
        eventsCount.Text = tostring(events)
        functionsCount.Text = tostring(functions)
    end
    
    -- Add entry to history list
    function self:AddHistoryEntry(entry)
        local HistoryEntry = Instance.new("Frame")
        HistoryEntry.Size = UDim2.new(1, 0, 0, 40)
        HistoryEntry.BackgroundColor3 = THEME.DarkContrast
        
        local EntryCorner = Instance.new("UICorner")
        EntryCorner.CornerRadius = UDim.new(0, 4)
        EntryCorner.Parent = HistoryEntry
        
        -- Remote name
        local Name = Instance.new("TextLabel")
        Name.Size = UDim2.new(1, -20, 0, 20)
        Name.Position = UDim2.new(0, 10, 0, 5)
        Name.BackgroundTransparency = 1
        Name.Text = entry.remoteName
        Name.TextColor3 = THEME.TextColor
        Name.TextSize = TEXT_SIZE.Regular
        Name.Font = Enum.Font.GothamSemibold
        Name.TextXAlignment = Enum.TextXAlignment.Left
        Name.Parent = HistoryEntry
        
        -- Timestamp
        local Timestamp = Instance.new("TextLabel")
        Timestamp.Size = UDim2.new(1, -20, 0, 20)
        Timestamp.Position = UDim2.new(0, 10, 0, 20)
        Timestamp.BackgroundTransparency = 1
        Timestamp.Text = os.date("%H:%M:%S", entry.timestamp)
        Timestamp.TextColor3 = THEME.PlaceholderColor
        Timestamp.TextSize = TEXT_SIZE.Small
        Timestamp.Font = Enum.Font.Gotham
        Timestamp.TextXAlignment = Enum.TextXAlignment.Left
        Timestamp.Parent = HistoryEntry
        
        HistoryEntry.Parent = HistoryList
        
        -- Auto scroll
        HistoryList.CanvasPosition = Vector2.new(0, HistoryList.CanvasSize.Y.Offset)
    end
    
    HistoryWindow.Parent = self.GUI
    return HistoryWindow
end

-- Enhance AddLogEntry to include history
local originalAddLogEntry = UILibrary.AddLogEntry
function UILibrary:AddLogEntry(remoteType, remoteName, args, source)
    -- Call original function
    originalAddLogEntry(self, remoteType, remoteName, args)
    
    -- Add to history
    self:AddToHistory(remoteType, remoteName, args, source)
end
-- Remote Call Blocking System
function UILibrary:CreateBlockingSystem()
    self.BlockedRemotes = {}
    self.HookedRemotes = {}
    
    -- Load blocked remotes from settings
    if self.Settings and self.Settings.BlockedRemotes then
        self.BlockedRemotes = self.Settings.BlockedRemotes
    end
    
    function self:BlockRemote(remoteName, remoteType)
        self.BlockedRemotes[remoteName] = {
            type = remoteType,
            timestamp = os.time()
        }
        
        -- Update settings
        if self.Settings then
            self.Settings.BlockedRemotes = self.BlockedRemotes
            self:SaveSettings()
        end
        
        -- Update UI
        self:UpdateRemoteUI(remoteName)
    end
    
    function self:UnblockRemote(remoteName)
        self.BlockedRemotes[remoteName] = nil
        
        -- Update settings
        if self.Settings then
            self.Settings.BlockedRemotes = self.BlockedRemotes
            self:SaveSettings()
        end
        
        -- Update UI
        self:UpdateRemoteUI(remoteName)
    end
    
    function self:IsBlocked(remoteName)
        return self.BlockedRemotes[remoteName] ~= nil
    end
end

-- Remote Hooking System
function UILibrary:CreateHookingSystem()
    self.HookedRemotes = {}
    self.HookFunctions = {}
    
    function self:HookRemote(remoteName, remoteType, callback)
        self.HookedRemotes[remoteName] = {
            type = remoteType,
            callback = callback,
            timestamp = os.time()
        }
        
        -- Apply hook based on remote type
        if remoteType == "RemoteEvent" then
            self:HookRemoteEvent(remoteName, callback)
        else
            self:HookRemoteFunction(remoteName, callback)
        end
        
        -- Update UI
        self:UpdateRemoteUI(remoteName)
    end
    
    function self:UnhookRemote(remoteName)
        if self.HookedRemotes[remoteName] then
            -- Remove hook
            local hookData = self.HookedRemotes[remoteName]
            if hookData.type == "RemoteEvent" then
                self:UnhookRemoteEvent(remoteName)
            else
                self:UnhookRemoteFunction(remoteName)
            end
            
            self.HookedRemotes[remoteName] = nil
            
            -- Update UI
            self:UpdateRemoteUI(remoteName)
        end
    end
    
    function self:HookRemoteEvent(remoteName, callback)
        local remote = game:GetService("ReplicatedStorage"):FindFirstChild(remoteName, true)
        if remote and remote:IsA("RemoteEvent") then
            local oldFireServer = remote.FireServer
            
            remote.FireServer = function(self, ...)
                local args = {...}
                
                -- Execute hook callback
                local shouldContinue, modifiedArgs = callback(args)
                
                -- Check if remote is blocked
                if UILibrary:IsBlocked(remoteName) then
                    return
                end
                
                -- Continue with original call if hook allows
                if shouldContinue then
                    return oldFireServer(self, unpack(modifiedArgs or args))
                end
            end
            
            self.HookFunctions[remoteName] = oldFireServer
        end
    end
    
    function self:HookRemoteFunction(remoteName, callback)
        local remote = game:GetService("ReplicatedStorage"):FindFirstChild(remoteName, true)
        if remote and remote:IsA("RemoteFunction") then
            local oldInvokeServer = remote.InvokeServer
            
            remote.InvokeServer = function(self, ...)
                local args = {...}
                
                -- Execute hook callback
                local shouldContinue, modifiedArgs = callback(args)
                
                -- Check if remote is blocked
                if UILibrary:IsBlocked(remoteName) then
                    return
                end
                
                -- Continue with original call if hook allows
                if shouldContinue then
                    return oldInvokeServer(self, unpack(modifiedArgs or args))
                end
            end
            
            self.HookFunctions[remoteName] = oldInvokeServer
        end
    end
    
    function self:UnhookRemoteEvent(remoteName)
        local remote = game:GetService("ReplicatedStorage"):FindFirstChild(remoteName, true)
        if remote and self.HookFunctions[remoteName] then
            remote.FireServer = self.HookFunctions[remoteName]
            self.HookFunctions[remoteName] = nil
        end
    end
    
    function self:UnhookRemoteFunction(remoteName)
        local remote = game:GetService("ReplicatedStorage"):FindFirstChild(remoteName, true)
        if remote and self.HookFunctions[remoteName] then
            remote.InvokeServer = self.HookFunctions[remoteName]
            self.HookFunctions[remoteName] = nil
        end
    end
end

-- Enhance UI elements with blocking and hooking controls
function UILibrary:CreateRemoteControls(logEntry, remoteName, remoteType)
    local ControlsContainer = Instance.new("Frame")
    ControlsContainer.Size = UDim2.new(0, 100, 1, -10)
    ControlsContainer.Position = UDim2.new(1, -110, 0, 5)
    ControlsContainer.BackgroundTransparency = 1
    
    local BlockButton = self:CreateButton(ControlsContainer, "", function()
        if self:IsBlocked(remoteName) then
            self:UnblockRemote(remoteName)
        else
            self:BlockRemote(remoteName, remoteType)
        end
    end)
    BlockButton.Size = UDim2.new(0, 30, 0, 30)
    BlockButton.Position = UDim2.new(0, 0, 0, 0)
    
    local BlockIcon = Instance.new("ImageLabel")
    BlockIcon.Size = UDim2.new(0.6, 0, 0.6, 0)
    BlockIcon.Position = UDim2.new(0.2, 0, 0.2, 0)
    BlockIcon.BackgroundTransparency = 1
    BlockIcon.Image = self:IsBlocked(remoteName) and "rbxassetid://blocked" or "rbxassetid://unblocked"
    BlockIcon.Parent = BlockButton
    
    local HookButton = self:CreateButton(ControlsContainer, "", function()
        if self.HookedRemotes[remoteName] then
            self:UnhookRemote(remoteName)
        else
            -- Open hook configuration window
            self:ShowHookConfig(remoteName, remoteType)
        end
    end)
    HookButton.Size = UDim2.new(0, 30, 0, 30)
    HookButton.Position = UDim2.new(0, 35, 0, 0)
    
    local HookIcon = Instance.new("ImageLabel")
    HookIcon.Size = UDim2.new(0.6, 0, 0.6, 0)
    HookIcon.Position = UDim2.new(0.2, 0, 0.2, 0)
    HookIcon.BackgroundTransparency = 1
    HookIcon.Image = self.HookedRemotes[remoteName] and "rbxassetid://hooked" or "rbxassetid://unhook"
    HookIcon.Parent = HookButton
    
    local InfoButton = self:CreateButton(ControlsContainer, "", function()
        self:ShowRemoteInfo(remoteName, remoteType)
    end)
    InfoButton.Size = UDim2.new(0, 30, 0, 30)
    InfoButton.Position = UDim2.new(0, 70, 0, 0)
    
    local InfoIcon = Instance.new("ImageLabel")
    InfoIcon.Size = UDim2.new(0.6, 0, 0.6, 0)
    InfoIcon.Position = UDim2.new(0.2, 0, 0.2, 0)
    InfoIcon.BackgroundTransparency = 1
    InfoIcon.Image = "rbxassetid://info"
    InfoIcon.Parent = InfoButton
    
    ControlsContainer.Parent = logEntry
    return ControlsContainer
end

-- Hook Configuration Window
function UILibrary:ShowHookConfig(remoteName, remoteType)
    local ConfigWindow = Instance.new("Frame")
    ConfigWindow.Size = UDim2.new(0, 400, 0, 300)
    ConfigWindow.Position = UDim2.new(0.5, -200, 0.5, -150)
    ConfigWindow.BackgroundColor3 = THEME.Background
    ConfigWindow.BorderSizePixel = 0
    
    local Corner = Instance.new("UICorner")
    Corner.CornerRadius = UDim.new(0, 6)
    Corner.Parent = ConfigWindow
    
    -- Header
    local Header = Instance.new("Frame")
    Header.Size = UDim2.new(1, 0, 0, 40)
    Header.BackgroundColor3 = THEME.DarkContrast
    Header.Parent = ConfigWindow
    
    local HeaderCorner = Instance.new("UICorner")
    HeaderCorner.CornerRadius = UDim.new(0, 6)
    HeaderCorner.Parent = Header
    
    local Title = Instance.new("TextLabel")
    Title.Size = UDim2.new(1, -40, 1, 0)
    Title.Position = UDim2.new(0, 10, 0, 0)
    Title.BackgroundTransparency = 1
    Title.Text = "Hook Configuration - " .. remoteName
    Title.TextColor3 = THEME.TextColor
    Title.TextSize = TEXT_SIZE.Title
    Title.Font = Enum.Font.GothamBold
    Title.TextXAlignment = Enum.TextXAlignment.Left
    Title.Parent = Header
    
    -- Code Editor
    local Editor = self:CreateCodeEditor(ConfigWindow)
    Editor.Size = UDim2.new(1, -20, 1, -100)
    Editor.Position = UDim2.new(0, 10, 0, 50)
    
    -- Default hook template
    local template = [[
-- Hook callback function
-- @param args: table of arguments passed to the remote
-- @return: boolean (continue original call), table (modified args)
return function(args)
    -- Modify args here
    
    return true, args
end
]]
    
    Editor.Text = template
    
    -- Apply button
    local ApplyButton = self:CreateButton(ConfigWindow, "Apply Hook", function()
        local success, callback = loadstring(Editor.Text)
        if success then
            self:HookRemote(remoteName, remoteType, callback())
            ConfigWindow:Destroy()
        else
            -- Show error
            self:ShowNotification("Hook Error", "Invalid hook code")
        end
    end)
    ApplyButton.Size = UDim2.new(0, 100, 0, 30)
    ApplyButton.Position = UDim2.new(1, -110, 1, -40)
    
    ConfigWindow.Parent = self.GUI
end

-- Remote Info Window
function UILibrary:ShowRemoteInfo(remoteName, remoteType)
    local InfoWindow = Instance.new("Frame")
    InfoWindow.Size = UDim2.new(0, 300, 0, 400)
    InfoWindow.Position = UDim2.new(0.5, -150, 0.5, -200)
    InfoWindow.BackgroundColor3 = THEME.Background
    InfoWindow.BorderSizePixel = 0
    
    -- Add remote information display here
    -- Including call history, average response time, etc.
    
    InfoWindow.Parent = self.GUI
end
-- Network Traffic Analysis System
function UILibrary:CreateNetworkAnalyzer()
    self.NetworkStats = {
        totalCalls = 0,
        bytesReceived = 0,
        bytesSent = 0,
        callsByRemote = {},
        timeStats = {},
        startTime = os.time()
    }
    
    function self:RecordNetworkCall(remoteName, callType, size, responseTime)
        -- Update global stats
        self.NetworkStats.totalCalls = self.NetworkStats.totalCalls + 1
        
        -- Update remote-specific stats
        if not self.NetworkStats.callsByRemote[remoteName] then
            self.NetworkStats.callsByRemote[remoteName] = {
                calls = 0,
                totalSize = 0,
                avgResponseTime = 0,
                lastCall = 0
            }
        end
        
        local remoteStats = self.NetworkStats.callsByRemote[remoteName]
        remoteStats.calls = remoteStats.calls + 1
        remoteStats.totalSize = remoteStats.totalSize + size
        remoteStats.lastCall = os.time()
        
        -- Update response time stats
        if responseTime then
            if not remoteStats.avgResponseTime then
                remoteStats.avgResponseTime = responseTime
            else
                remoteStats.avgResponseTime = (remoteStats.avgResponseTime * (remoteStats.calls - 1) + responseTime) / remoteStats.calls
            end
        end
        
        -- Update time-based stats
        local timeKey = os.date("%Y-%m-%d %H:%M")
        if not self.NetworkStats.timeStats[timeKey] then
            self.NetworkStats.timeStats[timeKey] = {
                calls = 0,
                size = 0
            }
        end
        
        local timeStats = self.NetworkStats.timeStats[timeKey]
        timeStats.calls = timeStats.calls + 1
        timeStats.size = timeStats.size + size
        
        -- Update UI
        self:UpdateNetworkUI()
    end
    
    function self:GetNetworkStats(remoteName)
        if remoteName then
            return self.NetworkStats.callsByRemote[remoteName]
        end
        return self.NetworkStats
    end
    
    function self:CreateNetworkGraph()
        local GraphContainer = Instance.new("Frame")
        GraphContainer.Size = UDim2.new(1, -20, 0, 200)
        GraphContainer.BackgroundColor3 = THEME.LightContrast
        GraphContainer.BorderSizePixel = 0
        
        local Graph = Instance.new("Frame")
        Graph.Size = UDim2.new(1, -20, 1, -40)
        Graph.Position = UDim2.new(0, 10, 0, 30)
        Graph.BackgroundTransparency = 1
        Graph.Parent = GraphContainer
        
        -- Create graph lines and labels here
        self:UpdateNetworkGraph(Graph)
        
        return GraphContainer
    end
    
    function self:UpdateNetworkGraph(graph)
        -- Clear existing graph
        for _, child in pairs(graph:GetChildren()) do
            child:Destroy()
        end
        
        -- Get last hour of stats
        local currentTime = os.time()
        local hourAgo = currentTime - 3600
        local stats = {}
        
        for timeKey, timeStats in pairs(self.NetworkStats.timeStats) do
            local timestamp = os.time({
                year = timeKey:sub(1,4),
                month = timeKey:sub(6,7),
                day = timeKey:sub(9,10),
                hour = timeKey:sub(12,13),
                min = timeKey:sub(15,16)
            })
            
            if timestamp >= hourAgo then
                table.insert(stats, {
                    timestamp = timestamp,
                    calls = timeStats.calls,
                    size = timeStats.size
                })
            end
        end
        
        -- Sort stats by timestamp
        table.sort(stats, function(a, b)
            return a.timestamp < b.timestamp
        end)
        
        -- Draw graph lines
        local maxCalls = 0
        for _, stat in pairs(stats) do
            maxCalls = math.max(maxCalls, stat.calls)
        end
        
        for i = 1, #stats do
            local stat = stats[i]
            local height = stat.calls / maxCalls
            
            local line = Instance.new("Frame")
            line.Size = UDim2.new(1/#stats, -2, height, 0)
            line.Position = UDim2.new((i-1)/#stats, 1, 1-height, 0)
            line.BackgroundColor3 = THEME.Accent
            line.BorderSizePixel = 0
            line.Parent = graph
        end
    end
end

-- Settings System
function UILibrary:CreateSettingsSystem()
    self.Settings = {
        theme = THEME,
        fontSize = TEXT_SIZE,
        blockedRemotes = {},
        filters = {},
        logLimit = 1000,
        autoScroll = true,
        showTimestamp = true,
        networkAnalysis = true
    }
    
    function self:LoadSettings()
        local success, savedSettings = pcall(function()
            return game:GetService("HttpService"):JSONDecode(
                readfile("RemoteSpySettings.json")
            )
        end)
        
        if success and savedSettings then
            -- Merge saved settings with defaults
            for key, value in pairs(savedSettings) do
                self.Settings[key] = value
            end
        end
        
        -- Apply loaded settings
        self:ApplySettings()
    end
    
    function self:SaveSettings()
        local success = pcall(function()
            writefile(
                "RemoteSpySettings.json",
                game:GetService("HttpService"):JSONEncode(self.Settings)
            )
        end)
        
        return success
    end
    
    function self:ApplySettings()
        -- Apply theme
        self:UpdateTheme(self.Settings.theme)
        
        -- Apply font sizes
        self:UpdateFontSizes(self.Settings.fontSize)
        
        -- Apply other settings
        self:UpdateLogDisplay()
        self:UpdateNetworkUI()
    end
    
    function self:CreateSettingsUI()
        local SettingsContainer = Instance.new("Frame")
        SettingsContainer.Size = UDim2.new(0, 300, 0, 400)
        SettingsContainer.Position = UDim2.new(0.5, -150, 0.5, -200)
        SettingsContainer.BackgroundColor3 = THEME.Background
        SettingsContainer.BorderSizePixel = 0
        SettingsContainer.Visible = false
        
        -- Create settings controls
        local ScrollFrame = Instance.new("ScrollingFrame")
        ScrollFrame.Size = UDim2.new(1, -20, 1, -60)
        ScrollFrame.Position = UDim2.new(0, 10, 0, 50)
        ScrollFrame.BackgroundTransparency = 1
        ScrollFrame.Parent = SettingsContainer
        
        local Layout = Instance.new("UIListLayout")
        Layout.Padding = UDim.new(0, 10)
        Layout.Parent = ScrollFrame
        
        -- Theme settings
        self:CreateSettingSection(ScrollFrame, "Theme", function(container)
            -- Theme color pickers
            for name, color in pairs(THEME) do
                self:CreateColorPicker(container, name, color, function(newColor)
                    self.Settings.theme[name] = newColor
                    self:ApplySettings()
                end)
            end
        end)
        
        -- Font size settings
        self:CreateSettingSection(ScrollFrame, "Font Sizes", function(container)
            for name, size in pairs(TEXT_SIZE) do
                self:CreateNumberInput(container, name, size, function(newSize)
                    self.Settings.fontSize[name] = newSize
                    self:ApplySettings()
                end)
            end
        end)
        
        -- General settings
        self:CreateSettingSection(ScrollFrame, "General", function(container)
            self:CreateToggle(container, "Auto Scroll", self.Settings.autoScroll, function(enabled)
                self.Settings.autoScroll = enabled
            end)
            
            self:CreateToggle(container, "Show Timestamp", self.Settings.showTimestamp, function(enabled)
                self.Settings.showTimestamp = enabled
                self:UpdateLogDisplay()
            end)
            
            self:CreateToggle(container, "Network Analysis", self.Settings.networkAnalysis, function(enabled)
                self.Settings.networkAnalysis = enabled
                self:UpdateNetworkUI()
            end)
            
            self:CreateNumberInput(container, "Log Limit", self.Settings.logLimit, function(newLimit)
                self.Settings.logLimit = newLimit
                self:TrimLogs()
            end)
        end)
        
        -- Save/Reset buttons
        local ButtonContainer = Instance.new("Frame")
        ButtonContainer.Size = UDim2.new(1, -20, 0, 30)
        ButtonContainer.Position = UDim2.new(0, 10, 1, -40)
        ButtonContainer.BackgroundTransparency = 1
        ButtonContainer.Parent = SettingsContainer
        
        local SaveButton = self:CreateButton(ButtonContainer, "Save", function()
            self:SaveSettings()
            SettingsContainer.Visible = false
        end)
        SaveButton.Size = UDim2.new(0.5, -5, 1, 0)
        
        local ResetButton = self:CreateButton(ButtonContainer, "Reset", function()
            self.Settings = self:GetDefaultSettings()
            self:ApplySettings()
            self:UpdateSettingsUI()
        end)
        ResetButton.Size = UDim2.new(0.5, -5, 1, 0)
        ResetButton.Position = UDim2.new(0.5, 5, 0, 0)
        
        return SettingsContainer
    end
end
-- Performance Optimization System
function UILibrary:CreatePerformanceOptimizer()
    self.PerformanceStats = {
        frameTimeHistory = {},
        memoryHistory = {},
        logProcessingTimes = {},
        lastUpdate = os.clock()
    }
    
    -- Frame time tracking
    function self:TrackFrameTime()
        local currentTime = os.clock()
        local frameTime = currentTime - self.PerformanceStats.lastUpdate
        self.PerformanceStats.lastUpdate = currentTime
        
        table.insert(self.PerformanceStats.frameTimeHistory, frameTime)
        if #self.PerformanceStats.frameTimeHistory > 60 then
            table.remove(self.PerformanceStats.frameTimeHistory, 1)
        end
        
        return frameTime
    end
    
    -- Memory usage tracking
    function self:TrackMemoryUsage()
        local memory = stats():GetTotalMemoryUsageMb()
        
        table.insert(self.PerformanceStats.memoryHistory, memory)
        if #self.PerformanceStats.memoryHistory > 60 then
            table.remove(self.PerformanceStats.memoryHistory, 1)
        end
        
        return memory
    end
    
    -- Log processing optimization
    function self:OptimizeLogProcessing(callback)
        local startTime = os.clock()
        
        -- Batch process logs
        local batchSize = 10
        local logs = {}
        
        return function(...)
            table.insert(logs, {...})
            
            if #logs >= batchSize then
                spawn(function()
                    local processingStart = os.clock()
                    
                    for _, log in ipairs(logs) do
                        callback(unpack(log))
                    end
                    
                    local processingTime = os.clock() - processingStart
                    table.insert(self.PerformanceStats.logProcessingTimes, processingTime)
                    
                    if #self.PerformanceStats.logProcessingTimes > 50 then
                        table.remove(self.PerformanceStats.logProcessingTimes, 1)
                    end
                end)
                
                logs = {}
            end
        end
    end
    
    -- UI Element pooling
    self.UIPool = {
        logEntries = {},
        buttons = {},
        labels = {}
    }
    
    function self:GetPooledElement(elementType, parent)
        local pool = self.UIPool[elementType]
        local element
        
        if #pool > 0 then
            element = table.remove(pool)
            element.Parent = parent
        else
            element = self:CreateNewElement(elementType)
            element.Parent = parent
        end
        
        return element
    end
    
    function self:RecycleElement(element, elementType)
        element.Parent = nil
        table.insert(self.UIPool[elementType], element)
    end
    
    -- Performance monitoring UI
    function self:CreatePerformanceUI()
        local PerformanceContainer = Instance.new("Frame")
        PerformanceContainer.Size = UDim2.new(0, 200, 0, 100)
        PerformanceContainer.Position = UDim2.new(1, -220, 0, 20)
        PerformanceContainer.BackgroundColor3 = THEME.Background
        PerformanceContainer.BorderSizePixel = 0
        
        local Stats = Instance.new("TextLabel")
        Stats.Size = UDim2.new(1, -20, 1, -20)
        Stats.Position = UDim2.new(0, 10, 0, 10)
        Stats.BackgroundTransparency = 1
        Stats.TextColor3 = THEME.TextColor
        Stats.TextSize = TEXT_SIZE.Small
        Stats.TextXAlignment = Enum.TextXAlignment.Left
        Stats.TextYAlignment = Enum.TextYAlignment.Top
        Stats.Parent = PerformanceContainer
        
        -- Update stats
        spawn(function()
            while wait(1) do
                local frameTimeAvg = self:GetAverageFrameTime()
                local memoryUsage = self:TrackMemoryUsage()
                local logProcessingAvg = self:GetAverageLogProcessingTime()
                
                Stats.Text = string.format(
                    "FPS: %.1f\nMemory: %.1f MB\nLog Processing: %.3f ms",
                    1/frameTimeAvg,
                    memoryUsage,
                    logProcessingAvg * 1000
                )
            end
        end)
        
        return PerformanceContainer
    end
end

-- Search and Filter System
function UILibrary:CreateSearchSystem()
    self.SearchFilters = {
        text = "",
        remoteTypes = {
            RemoteEvent = true,
            RemoteFunction = true
        },
        timeRange = {
            start = 0,
            finish = os.time()
        },
        customFilters = {}
    }
    
    function self:CreateSearchUI()
        local SearchContainer = Instance.new("Frame")
        SearchContainer.Size = UDim2.new(1, 0, 0, 40)
        SearchContainer.BackgroundColor3 = THEME.Background
        SearchContainer.BorderSizePixel = 0
        
        -- Search bar
        local SearchBox = Instance.new("TextBox")
        SearchBox.Size = UDim2.new(0.3, -20, 0, 30)
        SearchBox.Position = UDim2.new(0, 10, 0.5, -15)
        SearchBox.BackgroundColor3 = THEME.LightContrast
        SearchBox.TextColor3 = THEME.TextColor
        SearchBox.PlaceholderText = "Search..."
        SearchBox.Text = self.SearchFilters.text
        SearchBox.Parent = SearchContainer
        
        SearchBox:GetPropertyChangedSignal("Text"):Connect(function()
            self.SearchFilters.text = SearchBox.Text
            self:ApplyFilters()
        end)
        
        -- Remote type filters
        local TypeFilters = Instance.new("Frame")
        TypeFilters.Size = UDim2.new(0.2, -20, 1, -10)
        TypeFilters.Position = UDim2.new(0.3, 10, 0, 5)
        TypeFilters.BackgroundTransparency = 1
        TypeFilters.Parent = SearchContainer
        
        local function createTypeToggle(name, position)
            local toggle = self:CreateToggle(
                TypeFilters,
                name,
                self.SearchFilters.remoteTypes[name],
                function(enabled)
                    self.SearchFilters.remoteTypes[name] = enabled
                    self:ApplyFilters()
                end
            )
            toggle.Position = position
        end
        
        createTypeToggle("RemoteEvent", UDim2.new(0, 0, 0, 0))
        createTypeToggle("RemoteFunction", UDim2.new(0.5, 5, 0, 0))
        
        -- Time range selector
        local TimeRange = Instance.new("Frame")
        TimeRange.Size = UDim2.new(0.3, -20, 1, -10)
        TimeRange.Position = UDim2.new(0.5, 10, 0, 5)
        TimeRange.BackgroundTransparency = 1
        TimeRange.Parent = SearchContainer
        
        local StartTime = Instance.new("TextBox")
        StartTime.Size = UDim2.new(0.45, 0, 0, 30)
        StartTime.Position = UDim2.new(0, 0, 0.5, -15)
        StartTime.BackgroundColor3 = THEME.LightContrast
        StartTime.TextColor3 = THEME.TextColor
        StartTime.PlaceholderText = "Start time..."
        StartTime.Parent = TimeRange
        
        local EndTime = Instance.new("TextBox")
        EndTime.Size = UDim2.new(0.45, 0, 0, 30)
        EndTime.Position = UDim2.new(0.55, 0, 0.5, -15)
        EndTime.BackgroundColor3 = THEME.LightContrast
        EndTime.TextColor3 = THEME.TextColor
        EndTime.PlaceholderText = "End time..."
        EndTime.Parent = TimeRange
        
        local function updateTimeRange()
            local start = tonumber(StartTime.Text) or 0
            local finish = tonumber(EndTime.Text) or os.time()
            
            self.SearchFilters.timeRange.start = start
            self.SearchFilters.timeRange.finish = finish
            self:ApplyFilters()
        end
        
        StartTime:GetPropertyChangedSignal("Text"):Connect(updateTimeRange)
        EndTime:GetPropertyChangedSignal("Text"):Connect(updateTimeRange)
        
        -- Custom filter button
        local CustomFilterBtn = self:CreateButton(
            SearchContainer,
            "Custom Filter",
            function()
                self:ShowCustomFilterUI()
            end
        )
        CustomFilterBtn.Size = UDim2.new(0.15, -20, 0, 30)
        CustomFilterBtn.Position = UDim2.new(0.85, 10, 0.5, -15)
        
        return SearchContainer
    end
    
    function self:ShowCustomFilterUI()
        local FilterWindow = Instance.new("Frame")
        FilterWindow.Size = UDim2.new(0, 400, 0, 300)
        FilterWindow.Position = UDim2.new(0.5, -200, 0.5, -150)
        FilterWindow.BackgroundColor3 = THEME.Background
        FilterWindow.BorderSizePixel = 0
        
        -- Add custom filter configuration UI here
        local CodeEditor = self:CreateCodeEditor(FilterWindow)
        CodeEditor.Size = UDim2.new(1, -20, 1, -100)
        CodeEditor.Position = UDim2.new(0, 10, 0, 50)
        
        local template = [[
-- Custom filter function
-- @param log: table containing log entry data
-- @return: boolean (true to show entry, false to hide)
return function(log)
    -- Add filter logic here
    return true
end
]]
        
        CodeEditor.Text = template
        
        -- Apply button
        local ApplyButton = self:CreateButton(
            FilterWindow,
            "Apply Filter",
            function()
                local success, filter = loadstring(CodeEditor.Text)
                if success then
                    table.insert(self.SearchFilters.customFilters, filter())
                    self:ApplyFilters()
                    FilterWindow:Destroy()
                else
                    self:ShowNotification("Filter Error", "Invalid filter code")
                end
            end
        )
        ApplyButton.Size = UDim2.new(0, 100, 0, 30)
        ApplyButton.Position = UDim2.new(1, -110, 1, -40)
        
        FilterWindow.Parent = self.GUI
    end
    
    function self:ApplyFilters()
        for _, logEntry in pairs(self.LogContainer:GetChildren()) do
            if logEntry:IsA("Frame") then
                local log = logEntry.LogData
                
                -- Check if log passes all filters
                local visible = self:CheckFilters(log)
                logEntry.Visible = visible
            end
        end
    end
    
    function self:CheckFilters(log)
        -- Text search
        if self.SearchFilters.text ~= "" then
            local searchText = self.SearchFilters.text:lower()
            local logText = (log.name .. log.type .. tostring(log.args)):lower()
            
            if not string.find(logText, searchText) then
                return false
            end
        end
        
        -- Remote type filter
        if not self.SearchFilters.remoteTypes[log.type] then
            return false
        end
        
        -- Time range filter
        if log.timestamp < self.SearchFilters.timeRange.start or 
           log.timestamp > self.SearchFilters.timeRange.finish then
            return false
        end
        
        -- Custom filters
        for _, filter in ipairs(self.SearchFilters.customFilters) do
            if not filter(log) then
                return false
            end
        end
        
        return true
    end
end
-- Export/Import System
function UILibrary:CreateExportSystem()
    function self:ExportLogs(format)
        local logs = {}
        
        -- Collect all logs
        for _, logEntry in pairs(self.LogContainer:GetChildren()) do
            if logEntry:IsA("Frame") and logEntry.LogData then
                table.insert(logs, logEntry.LogData)
            end
        end
        
        -- Export based on format
        if format == "JSON" then
            return self:ExportJSON(logs)
        elseif format == "Lua" then
            return self:ExportLua(logs)
        elseif format == "CSV" then
            return self:ExportCSV(logs)
        end
    end
    
    function self:ExportJSON(logs)
        local HttpService = game:GetService("HttpService")
        return HttpService:JSONEncode(logs)
    end
    
    function self:ExportLua(logs)
        local output = "return {\n"
        
        for _, log in ipairs(logs) do
            output = output .. "    {\n"
            output = output .. string.format("        name = %q,\n", log.name)
            output = output .. string.format("        type = %q,\n", log.type)
            output = output .. string.format("        timestamp = %d,\n", log.timestamp)
            
            -- Handle args
            output = output .. "        args = {\n"
            for i, arg in ipairs(log.args) do
                output = output .. "            " .. self:ValueToLuaString(arg) .. ",\n"
            end
            output = output .. "        },\n"
            
            if log.returnValue then
                output = output .. "        returnValue = " .. self:ValueToLuaString(log.returnValue) .. ",\n"
            end
            
            output = output .. "    },\n"
        end
        
        output = output .. "}"
        return output
    end
    
    function self:ExportCSV(logs)
        local output = "Timestamp,Type,Name,Arguments,ReturnValue\n"
        
        for _, log in ipairs(logs) do
            local args = table.concat(self:ArgsToStrings(log.args), "|")
            local returnVal = log.returnValue and tostring(log.returnValue) or ""
            
            output = output .. string.format(
                "%d,%s,%s,%s,%s\n",
                log.timestamp,
                log.type,
                log.name,
                args,
                returnVal
            )
        end
        
        return output
    end
    
    function self:ValueToLuaString(value)
        local valueType = typeof(value)
        
        if valueType == "string" then
            return string.format("%q", value)
        elseif valueType == "number" or valueType == "boolean" then
            return tostring(value)
        elseif valueType == "table" then
            local result = "{"
            for k, v in pairs(value) do
                local keyStr = type(k) == "string" and string.format("[%q]", k) or "["..tostring(k).."]"
                result = result .. keyStr .. "=" .. self:ValueToLuaString(v) .. ","
            end
            return result .. "}"
        elseif valueType == "Vector3" then
            return string.format("Vector3.new(%f, %f, %f)", value.X, value.Y, value.Z)
        elseif valueType == "CFrame" then
            return string.format("CFrame.new(%f, %f, %f)", value.X, value.Y, value.Z)
        else
            return '"'..tostring(value)..'"'
        end
    end
    
    function self:ArgsToStrings(args)
        local result = {}
        for _, arg in ipairs(args) do
            table.insert(result, tostring(arg))
        end
        return result
    end
    
    function self:ImportLogs(data, format)
        local success, logs = pcall(function()
            if format == "JSON" then
                return game:GetService("HttpService"):JSONDecode(data)
            elseif format == "Lua" then
                local func = loadstring(data)
                return func and func() or error("Invalid Lua data")
            end
        end)
        
        if success then
            -- Clear existing logs
            for _, child in pairs(self.LogContainer:GetChildren()) do
                child:Destroy()
            end
            
            -- Add imported logs
            for _, log in ipairs(logs) do
                self:AddLogEntry(log)
            end
            
            return true
        end
        
        return false
    end
    
    function self:CreateExportUI()
        local ExportFrame = Instance.new("Frame")
        ExportFrame.Size = UDim2.new(0, 300, 0, 200)
        ExportFrame.Position = UDim2.new(0.5, -150, 0.5, -100)
        ExportFrame.BackgroundColor3 = THEME.Background
        ExportFrame.BorderSizePixel = 0
        ExportFrame.Visible = false
        
        -- Format selection
        local FormatLabel = Instance.new("TextLabel")
        FormatLabel.Size = UDim2.new(1, -20, 0, 30)
        FormatLabel.Position = UDim2.new(0, 10, 0, 10)
        FormatLabel.BackgroundTransparency = 1
        FormatLabel.TextColor3 = THEME.TextColor
        FormatLabel.Text = "Export Format:"
        FormatLabel.Parent = ExportFrame
        
        local formats = {"JSON", "Lua", "CSV"}
        local selectedFormat = formats[1]
        
        for i, format in ipairs(formats) do
            local button = self:CreateButton(
                ExportFrame,
                format,
                function()
                    selectedFormat = format
                end
            )
            button.Size = UDim2.new(0.3, -10, 0, 30)
            button.Position = UDim2.new((i-1)*0.33 + 0.02, 0, 0, 50)
        end
        
        -- Export button
        local ExportButton = self:CreateButton(
            ExportFrame,
            "Export",
            function()
                local data = self:ExportLogs(selectedFormat)
                if data then
                    setclipboard(data)
                    self:ShowNotification("Export Success", "Data copied to clipboard")
                end
            end
        )
        ExportButton.Size = UDim2.new(0.5, -15, 0, 30)
        ExportButton.Position = UDim2.new(0, 10, 1, -40)
        
        -- Import button
        local ImportButton = self:CreateButton(
            ExportFrame,
            "Import",
            function()
                local data = getclipboard()
                if data then
                    local success = self:ImportLogs(data, selectedFormat)
                    if success then
                        self:ShowNotification("Import Success", "Logs imported successfully")
                    else
                        self:ShowNotification("Import Error", "Failed to import logs")
                    end
                end
            end
        )
        ImportButton.Size = UDim2.new(0.5, -15, 0, 30)
        ImportButton.Position = UDim2.new(0.5, 5, 1, -40)
        
        return ExportFrame
    end
end

-- Remote Call Replication
function UILibrary:CreateRemoteReplication()
    self.ReplicatedCalls = {}
    
    function self:ReplicateRemoteCall(log)
        -- Store call for replication
        table.insert(self.ReplicatedCalls, log)
        
        -- Update UI
        self:UpdateReplicationUI()
    end
    
    function self:ExecuteReplicatedCall(log)
        local remote = log.instance
        
        if not remote then
            self:ShowNotification("Error", "Remote instance not found")
            return false
        end
        
        -- Execute based on remote type
        if log.type == "RemoteEvent" then
            remote:FireServer(unpack(log.args))
            return true
        elseif log.type == "RemoteFunction" then
            spawn(function()
                local result = remote:InvokeServer(unpack(log.args))
                self:ShowNotification("Function Result", tostring(result))
            end)
            return true
        end
        
        return false
    end
    
    function self:CreateReplicationUI()
        local ReplicationFrame = Instance.new("Frame")
        ReplicationFrame.Size = UDim2.new(0, 300, 0, 400)
        ReplicationFrame.Position = UDim2.new(1, -320, 0, 20)
        ReplicationFrame.BackgroundColor3 = THEME.Background
        ReplicationFrame.BorderSizePixel = 0
        ReplicationFrame.Visible = false
        
        -- Calls list
        local ScrollFrame = Instance.new("ScrollingFrame")
        ScrollFrame.Size = UDim2.new(1, -20, 1, -60)
        ScrollFrame.Position = UDim2.new(0, 10, 0, 50)
        ScrollFrame.BackgroundTransparency = 1
        ScrollFrame.Parent = ReplicationFrame
        
        local Layout = Instance.new("UIListLayout")
        Layout.Padding = UDim.new(0, 5)
        Layout.Parent = ScrollFrame
        
        -- Update function
        function self:UpdateReplicationUI()
            -- Clear existing entries
            for _, child in pairs(ScrollFrame:GetChildren()) do
                if child:IsA("Frame") then
                    child:Destroy()
                end
            end
            
            -- Add call entries
            for i, call in ipairs(self.ReplicatedCalls) do
                local entry = Instance.new("Frame")
                entry.Size = UDim2.new(1, -10, 0, 60)
                entry.BackgroundColor3 = THEME.LightContrast
                entry.BorderSizePixel = 0
                
                -- Call info
                local info = Instance.new("TextLabel")
                info.Size = UDim2.new(1, -70, 1, 0)
                info.Position = UDim2.new(0, 5, 0, 0)
                info.BackgroundTransparency = 1
                info.TextColor3 = THEME.TextColor
                info.TextXAlignment = Enum.TextXAlignment.Left
                info.TextYAlignment = Enum.TextYAlignment.Top
                info.TextWrapped = true
                info.Text = string.format(
                    "%s\nType: %s\nArgs: %s",
                    call.name,
                    call.type,
                    table.concat(self:ArgsToStrings(call.args), ", ")
                )
                info.Parent = entry
                
                -- Execute button
                local execButton = self:CreateButton(
                    entry,
                    "Run",
                    function()
                        self:ExecuteReplicatedCall(call)
                    end
                )
                execButton.Size = UDim2.new(0, 50, 0, 25)
                execButton.Position = UDim2.new(1, -55, 0.5, -12.5)
                
                entry.Parent = ScrollFrame
            end
        end
        
        -- Clear button
        local ClearButton = self:CreateButton(
            ReplicationFrame,
            "Clear All",
            function()
                self.ReplicatedCalls = {}
                self:UpdateReplicationUI()
            end
        )
        ClearButton.Size = UDim2.new(0, 70, 0, 25)
        ClearButton.Position = UDim2.new(1, -80, 0, 10)
        
        return ReplicationFrame
    end
end
-- Advanced Logging Features
function UILibrary:EnhanceLogging()
    self.LogFilters = {
        types = {},
        search = "",
        timeRange = {min = 0, max = os.time()}
    }
    
    function self:SetLogFilter(filterType, value)
        if filterType == "type" then
            self.LogFilters.types[value] = not self.LogFilters.types[value]
        elseif filterType == "search" then
            self.LogFilters.search = value
        elseif filterType == "timeRange" then
            self.LogFilters.timeRange = value
        end
        
        self:ApplyLogFilters()
    end
    
    function self:ApplyLogFilters()
        for _, logEntry in pairs(self.LogContainer:GetChildren()) do
            if logEntry:IsA("Frame") and logEntry.LogData then
                local data = logEntry.LogData
                local visible = true
                
                -- Type filter
                if next(self.LogFilters.types) then
                    visible = visible and self.LogFilters.types[data.type]
                end
                
                -- Search filter
                if self.LogFilters.search ~= "" then
                    local searchLower = self.LogFilters.search:lower()
                    local nameMatch = data.name:lower():find(searchLower)
                    local argsMatch = table.concat(self:ArgsToStrings(data.args)):lower():find(searchLower)
                    visible = visible and (nameMatch or argsMatch)
                end
                
                -- Time range filter
                visible = visible and (
                    data.timestamp >= self.LogFilters.timeRange.min and 
                    data.timestamp <= self.LogFilters.timeRange.max
                )
                
                logEntry.Visible = visible
            end
        end
    end
    
    -- Enhanced log entry creation
    function self:EnhanceLogEntry(entry, data)
        -- Stack trace
        local stackTrace = debug.traceback()
        local stackButton = self:CreateButton(
            entry,
            "Stack",
            function()
                self:ShowStackTrace(stackTrace)
            end
        )
        stackButton.Size = UDim2.new(0, 50, 0, 20)
        stackButton.Position = UDim2.new(1, -120, 0, 5)
        
        -- Performance timing
        if data.type == "RemoteFunction" then
            local startTime = tick()
            local originalCallback = entry.Callback
            
            entry.Callback = function(...)
                local endTime = tick()
                local duration = endTime - startTime
                self:UpdateCallDuration(entry, duration)
                return originalCallback(...)
            end
        end
    end
    
    function self:ShowStackTrace(stackTrace)
        local frame = Instance.new("Frame")
        frame.Size = UDim2.new(0, 400, 0, 300)
        frame.Position = UDim2.new(0.5, -200, 0.5, -150)
        frame.BackgroundColor3 = THEME.Background
        frame.BorderSizePixel = 0
        
        local text = Instance.new("TextBox")
        text.Size = UDim2.new(1, -20, 1, -20)
        text.Position = UDim2.new(0, 10, 0, 10)
        text.BackgroundTransparency = 1
        text.TextColor3 = THEME.TextColor
        text.TextXAlignment = Enum.TextXAlignment.Left
        text.TextYAlignment = Enum.TextYAlignment.Top
        text.TextWrapped = true
        text.Text = stackTrace
        text.Parent = frame
        
        frame.Parent = self.GUI
    end
    
    function self:UpdateCallDuration(entry, duration)
        if not entry:FindFirstChild("DurationLabel") then
            local label = Instance.new("TextLabel")
            label.Name = "DurationLabel"
            label.Size = UDim2.new(0, 70, 0, 20)
            label.Position = UDim2.new(1, -190, 0, 5)
            label.BackgroundTransparency = 1
            label.TextColor3 = THEME.TextColor
            label.Parent = entry
        end
        
        entry.DurationLabel.Text = string.format("%.2fms", duration * 1000)
    end
end

-- Debugging Tools
function UILibrary:CreateDebuggingTools()
    self.DebugSettings = {
        breakpoints = {},
        valueTracking = {},
        errorHandling = true
    }
    
    function self:SetBreakpoint(remoteName, condition)
        self.DebugSettings.breakpoints[remoteName] = condition
    end
    
    function self:TrackValue(valueName, getValue)
        self.DebugSettings.valueTracking[valueName] = getValue
        self:UpdateValueTracker()
    end
    
    function self:HandleRemoteDebug(log)
        local name = log.name
        
        -- Check breakpoints
        if self.DebugSettings.breakpoints[name] then
            local condition = self.DebugSettings.breakpoints[name]
            if condition(log.args) then
                self:PauseExecution(log)
            end
        end
        
        -- Error handling
        if self.DebugSettings.errorHandling then
            local success, result = pcall(function()
                return log.callback(unpack(log.args))
            end)
            
            if not success then
                self:LogError(name, result)
                return
            end
            
            return result
        end
    end
    
    function self:PauseExecution(log)
        local frame = Instance.new("Frame")
        frame.Size = UDim2.new(0, 400, 0, 300)
        frame.Position = UDim2.new(0.5, -200, 0.5, -150)
        frame.BackgroundColor3 = THEME.Background
        frame.BorderSizePixel = 0
        
        -- Debug info
        local info = Instance.new("TextLabel")
        info.Size = UDim2.new(1, -20, 0, 100)
        info.Position = UDim2.new(0, 10, 0, 10)
        info.BackgroundTransparency = 1
        info.TextColor3 = THEME.TextColor
        info.TextXAlignment = Enum.TextXAlignment.Left
        info.TextWrapped = true
        info.Text = string.format(
            "Breakpoint hit:\nRemote: %s\nArgs: %s",
            log.name,
            table.concat(self:ArgsToStrings(log.args), ", ")
        )
        info.Parent = frame
        
        -- Variable inspector
        local inspector = Instance.new("ScrollingFrame")
        inspector.Size = UDim2.new(1, -20, 1, -160)
        inspector.Position = UDim2.new(0, 10, 0, 120)
        inspector.BackgroundTransparency = 1
        inspector.Parent = frame
        
        local layout = Instance.new("UIListLayout")
        layout.Padding = UDim.new(0, 5)
        layout.Parent = inspector
        
        -- Show tracked values
        for name, getValue in pairs(self.DebugSettings.valueTracking) do
            local value = getValue()
            local valueLabel = Instance.new("TextLabel")
            valueLabel.Size = UDim2.new(1, 0, 0, 20)
            valueLabel.BackgroundTransparency = 1
            valueLabel.TextColor3 = THEME.TextColor
            valueLabel.TextXAlignment = Enum.TextXAlignment.Left
            valueLabel.Text = string.format("%s: %s", name, tostring(value))
            valueLabel.Parent = inspector
        end
        
        -- Continue button
        local continueButton = self:CreateButton(
            frame,
            "Continue",
            function()
                frame:Destroy()
            end
        )
        continueButton.Size = UDim2.new(0, 100, 0, 30)
        continueButton.Position = UDim2.new(0.5, -50, 1, -40)
        
        frame.Parent = self.GUI
    end
    
    function self:LogError(name, error)
        local entry = self:CreateBasicEntry({
            name = name,
            type = "Error",
            args = {error},
            timestamp = os.time()
        })
        
        entry.BackgroundColor3 = Color3.fromRGB(255, 200, 200)
    end
    
    function self:CreateDebugUI()
        local DebugFrame = Instance.new("Frame")
        DebugFrame.Size = UDim2.new(0, 300, 0, 400)
        DebugFrame.Position = UDim2.new(1, -320, 0.5, -200)
        DebugFrame.BackgroundColor3 = THEME.Background
        DebugFrame.BorderSizePixel = 0
        DebugFrame.Visible = false
        
        -- Breakpoints
        local breakpointsLabel = Instance.new("TextLabel")
        breakpointsLabel.Size = UDim2.new(1, -20, 0, 30)
        breakpointsLabel.Position = UDim2.new(0, 10, 0, 10)
        breakpointsLabel.BackgroundTransparency = 1
        breakpointsLabel.TextColor3 = THEME.TextColor
        breakpointsLabel.Text = "Breakpoints"
        breakpointsLabel.Parent = DebugFrame
        
        local breakpointsList = Instance.new("ScrollingFrame")
        breakpointsList.Size = UDim2.new(1, -20, 0, 100)
        breakpointsList.Position = UDim2.new(0, 10, 0, 50)
        breakpointsList.BackgroundTransparency = 1
        breakpointsList.Parent = DebugFrame
        
        -- Value tracking
        local trackingLabel = Instance.new("TextLabel")
        trackingLabel.Size = UDim2.new(1, -20, 0, 30)
        trackingLabel.Position = UDim2.new(0, 10, 0, 170)
        trackingLabel.BackgroundTransparency = 1
        trackingLabel.TextColor3 = THEME.TextColor
        trackingLabel.Text = "Value Tracking"
        trackingLabel.Parent = DebugFrame
        
        local trackingList = Instance.new("ScrollingFrame")
        trackingList.Size = UDim2.new(1, -20, 0, 100)
        trackingList.Position = UDim2.new(0, 10, 0, 210)
        trackingList.BackgroundTransparency = 1
        trackingList.Parent = DebugFrame
        
        -- Error handling toggle
        local errorToggle = self:CreateToggle(
            DebugFrame,
            "Error Handling",
            self.DebugSettings.errorHandling,
            function(value)
                self.DebugSettings.errorHandling = value
            end
        )
        errorToggle.Position = UDim2.new(0, 10, 1, -40)
        
        return DebugFrame
    end
end
-- Documentation Generation
function UILibrary:CreateDocumentationSystem()
    self.Documentation = {
        remotes = {},
        categories = {},
        examples = {}
    }
    
    function self:AddRemoteDoc(name, docInfo)
        self.Documentation.remotes[name] = {
            description = docInfo.description,
            parameters = docInfo.parameters or {},
            returns = docInfo.returns,
            category = docInfo.category,
            examples = docInfo.examples or {},
            notes = docInfo.notes
        }
    end
    
    function self:AddCategory(name, description)
        self.Documentation.categories[name] = description
    end
    
    function self:AddExample(name, example)
        self.Documentation.examples[name] = example
    end
    
    function self:GenerateDocumentation()
        local markdown = "# Remote Documentation\n\n"
        
        -- Categories
        markdown = markdown .. "## Categories\n\n"
        for name, desc in pairs(self.Documentation.categories) do
            markdown = markdown .. string.format("### %s\n%s\n\n", name, desc)
        end
        
        -- Remotes
        markdown = markdown .. "## Remote Details\n\n"
        for name, info in pairs(self.Documentation.remotes) do
            markdown = markdown .. self:FormatRemoteDoc(name, info)
        end
        
        -- Examples
        markdown = markdown .. "## Examples\n\n"
        for name, example in pairs(self.Documentation.examples) do
            markdown = markdown .. string.format("### %s\n```lua\n%s\n```\n\n", name, example)
        end
        
        return markdown
    end
    
    function self:FormatRemoteDoc(name, info)
        local doc = string.format("### %s\n%s\n\n", name, info.description)
        
        if info.category then
            doc = doc .. string.format("**Category:** %s\n\n", info.category)
        end
        
        if #info.parameters > 0 then
            doc = doc .. "**Parameters:**\n\n"
            for _, param in ipairs(info.parameters) do
                doc = doc .. string.format("- `%s` (%s): %s\n", 
                    param.name, param.type, param.description)
            end
            doc = doc .. "\n"
        end
        
        if info.returns then
            doc = doc .. string.format("**Returns:** %s\n\n", info.returns)
        end
        
        if #info.examples > 0 then
            doc = doc .. "**Examples:**\n\n"
            for _, example in ipairs(info.examples) do
                doc = doc .. string.format("```lua\n%s\n```\n\n", example)
            end
        end
        
        if info.notes then
            doc = doc .. string.format("**Notes:** %s\n\n", info.notes)
        end
        
        return doc
    end
    
    function self:CreateDocumentationUI()
        local DocFrame = Instance.new("Frame")
        DocFrame.Size = UDim2.new(0, 500, 0, 400)
        DocFrame.Position = UDim2.new(0.5, -250, 0.5, -200)
        DocFrame.BackgroundColor3 = THEME.Background
        DocFrame.BorderSizePixel = 0
        DocFrame.Visible = false
        
        -- Documentation content
        local Content = Instance.new("ScrollingFrame")
        Content.Size = UDim2.new(1, -20, 1, -60)
        Content.Position = UDim2.new(0, 10, 0, 50)
        Content.BackgroundTransparency = 1
        Content.Parent = DocFrame
        
        -- Category filters
        local CategoryButtons = Instance.new("Frame")
        CategoryButtons.Size = UDim2.new(1, -20, 0, 30)
        CategoryButtons.Position = UDim2.new(0, 10, 0, 10)
        CategoryButtons.BackgroundTransparency = 1
        CategoryButtons.Parent = DocFrame
        
        local Layout = Instance.new("UIListLayout")
        Layout.FillDirection = Enum.FillDirection.Horizontal
        Layout.Padding = UDim.new(0, 5)
        Layout.Parent = CategoryButtons
        
        -- Export button
        local ExportButton = self:CreateButton(
            DocFrame,
            "Export Markdown",
            function()
                setclipboard(self:GenerateDocumentation())
                self:ShowNotification("Documentation Exported", "Markdown copied to clipboard")
            end
        )
        ExportButton.Size = UDim2.new(0, 100, 0, 30)
        ExportButton.Position = UDim2.new(1, -110, 0, 10)
        
        return DocFrame
    end
end

-- Settings System
function UILibrary:CreateSettingsSystem()
    self.Settings = {
        theme = THEME,
        autoScroll = true,
        timestampFormat = "%H:%M:%S",
        maxLogs = 1000,
        filterDefaults = {
            showRemoteEvents = true,
            showRemoteFunctions = true,
            showErrors = true
        },
        debugDefaults = {
            enableErrorHandling = true,
            stackTraceEnabled = true
        }
    }
    
    function self:SaveSettings()
        local HttpService = game:GetService("HttpService")
        local json = HttpService:JSONEncode(self.Settings)
        writefile("RemoteSpySettings.json", json)
    end
    
    function self:LoadSettings()
        if isfile("RemoteSpySettings.json") then
            local success, settings = pcall(function()
                local HttpService = game:GetService("HttpService")
                return HttpService:JSONDecode(readfile("RemoteSpySettings.json"))
            end)
            
            if success then
                -- Merge loaded settings with defaults
                for key, value in pairs(settings) do
                    self.Settings[key] = value
                end
                
                -- Apply loaded settings
                self:ApplySettings()
            end
        end
    end
    
    function self:ApplySettings()
        -- Apply theme
        self:ApplyTheme(self.Settings.theme)
        
        -- Apply other settings
        self.MaxLogs = self.Settings.maxLogs
        self:UpdateAutoScroll(self.Settings.autoScroll)
        
        -- Apply filter defaults
        for key, value in pairs(self.Settings.filterDefaults) do
            self:SetLogFilter("type", key, value)
        end
        
        -- Apply debug defaults
        self.DebugSettings.errorHandling = self.Settings.debugDefaults.enableErrorHandling
        
        -- Update UI
        self:UpdateSettingsUI()
    end
    
    function self:CreateSettingsUI()
        local SettingsFrame = Instance.new("Frame")
        SettingsFrame.Size = UDim2.new(0, 300, 0, 400)
        SettingsFrame.Position = UDim2.new(0.5, -150, 0.5, -200)
        SettingsFrame.BackgroundColor3 = THEME.Background
        SettingsFrame.BorderSizePixel = 0
        SettingsFrame.Visible = false
        
        -- Theme settings
        local ThemeLabel = Instance.new("TextLabel")
        ThemeLabel.Size = UDim2.new(1, -20, 0, 30)
        ThemeLabel.Position = UDim2.new(0, 10, 0, 10)
        ThemeLabel.BackgroundTransparency = 1
        ThemeLabel.TextColor3 = THEME.TextColor
        ThemeLabel.Text = "Theme"
        ThemeLabel.Parent = SettingsFrame
        
        local themes = {
            Dark = {
                Background = Color3.fromRGB(30, 30, 30),
                LightContrast = Color3.fromRGB(40, 40, 40),
                TextColor = Color3.fromRGB(255, 255, 255)
            },
            Light = {
                Background = Color3.fromRGB(240, 240, 240),
                LightContrast = Color3.fromRGB(220, 220, 220),
                TextColor = Color3.fromRGB(0, 0, 0)
            }
        }
        
        for name, theme in pairs(themes) do
            local button = self:CreateButton(
                SettingsFrame,
                name,
                function()
                    self.Settings.theme = theme
                    self:ApplySettings()
                end
            )
            button.Size = UDim2.new(0.4, -10, 0, 30)
            button.Position = name == "Dark" and 
                UDim2.new(0.1, 0, 0, 50) or 
                UDim2.new(0.5, 10, 0, 50)
        end
        
        -- General settings
        local generalY = 100
        
        -- Auto-scroll toggle
        local autoScrollToggle = self:CreateToggle(
            SettingsFrame,
            "Auto-scroll",
            self.Settings.autoScroll,
            function(value)
                self.Settings.autoScroll = value
                self:SaveSettings()
            end
        )
        autoScrollToggle.Position = UDim2.new(0, 10, 0, generalY)
        
        -- Max logs slider
        local maxLogsLabel = Instance.new("TextLabel")
        maxLogsLabel.Size = UDim2.new(1, -20, 0, 30)
        maxLogsLabel.Position = UDim2.new(0, 10, 0, generalY + 40)
        maxLogsLabel.BackgroundTransparency = 1
        maxLogsLabel.TextColor3 = THEME.TextColor
        maxLogsLabel.Text = "Max Logs: " .. self.Settings.maxLogs
        maxLogsLabel.Parent = SettingsFrame
        
        local maxLogsSlider = Instance.new("TextButton")
        maxLogsSlider.Size = UDim2.new(1, -20, 0, 20)
        maxLogsSlider.Position = UDim2.new(0, 10, 0, generalY + 70)
        maxLogsSlider.BackgroundColor3 = THEME.LightContrast
        maxLogsSlider.Parent = SettingsFrame
        
        -- Filter defaults
        local filterY = generalY + 100
        
        for name, default in pairs(self.Settings.filterDefaults) do
            local toggle = self:CreateToggle(
                SettingsFrame,
                "Show " .. name,
                default,
                function(value)
                    self.Settings.filterDefaults[name] = value
                    self:SaveSettings()
                end
            )
            toggle.Position = UDim2.new(0, 10, 0, filterY)
            filterY = filterY + 30
        end
        
        -- Debug settings
        local debugY = filterY + 20
        
        for name, default in pairs(self.Settings.debugDefaults) do
            local toggle = self:CreateToggle(
                SettingsFrame,
                name,
                default,
                function(value)
                    self.Settings.debugDefaults[name] = value
                    self:SaveSettings()
                end
            )
            toggle.Position = UDim2.new(0, 10, 0, debugY)
            debugY = debugY + 30
        end
        
        -- Reset button
        local ResetButton = self:CreateButton(
            SettingsFrame,
            "Reset to Defaults",
            function()
                self.Settings = self:GetDefaultSettings()
                self:ApplySettings()
                self:SaveSettings()
            end
        )
        ResetButton.Size = UDim2.new(0, 120, 0, 30)
        ResetButton.Position = UDim2.new(0.5, -60, 1, -40)
        
        return SettingsFrame
    end
    
    function self:GetDefaultSettings()
        return {
            theme = THEME,
            autoScroll = true,
            timestampFormat = "%H:%M:%S",
            maxLogs = 1000,
            filterDefaults = {
                showRemoteEvents = true,
                showRemoteFunctions = true,
                showErrors = true
            },
            debugDefaults = {
                enableErrorHandling = true,
                stackTraceEnabled = true
            }
        }
    end
end
-- UI Themes and Customization
function UILibrary:EnhanceTheming()
    self.CustomThemes = {
        Dark = {
            Background = Color3.fromRGB(30, 30, 30),
            LightContrast = Color3.fromRGB(40, 40, 40),
            DarkContrast = Color3.fromRGB(25, 25, 25),
            TextColor = Color3.fromRGB(255, 255, 255),
            AccentColor = Color3.fromRGB(0, 120, 255),
            ErrorColor = Color3.fromRGB(255, 0, 0),
            SuccessColor = Color3.fromRGB(0, 255, 0),
            WarningColor = Color3.fromRGB(255, 165, 0),
            BorderColor = Color3.fromRGB(60, 60, 60),
            ScrollBarColor = Color3.fromRGB(50, 50, 50)
        },
        Light = {
            Background = Color3.fromRGB(240, 240, 240),
            LightContrast = Color3.fromRGB(250, 250, 250),
            DarkContrast = Color3.fromRGB(230, 230, 230),
            TextColor = Color3.fromRGB(0, 0, 0),
            AccentColor = Color3.fromRGB(0, 100, 200),
            ErrorColor = Color3.fromRGB(200, 0, 0),
            SuccessColor = Color3.fromRGB(0, 200, 0),
            WarningColor = Color3.fromRGB(200, 130, 0),
            BorderColor = Color3.fromRGB(200, 200, 200),
            ScrollBarColor = Color3.fromRGB(180, 180, 180)
        }
    }
    
    function self:CreateCustomTheme(name, colors)
        self.CustomThemes[name] = colors
        self:UpdateThemeSelector()
    end
    
    function self:ApplyTheme(theme)
        -- Apply to main UI
        self.GUI.BackgroundColor3 = theme.Background
        
        -- Apply to all frames
        for _, obj in ipairs(self.GUI:GetDescendants()) do
            if obj:IsA("Frame") then
                if obj.Name:match("Contrast") then
                    obj.BackgroundColor3 = theme.LightContrast
                else
                    obj.BackgroundColor3 = theme.Background
                end
            elseif obj:IsA("TextLabel") or obj:IsA("TextBox") or obj:IsA("TextButton") then
                obj.TextColor3 = theme.TextColor
            elseif obj:IsA("ScrollingFrame") then
                obj.ScrollBarImageColor3 = theme.ScrollBarColor
            end
        end
        
        -- Update log entries
        for _, entry in ipairs(self.LogContainer:GetChildren()) do
            if entry:IsA("Frame") and entry.LogData then
                local data = entry.LogData
                if data.type == "Error" then
                    entry.BackgroundColor3 = theme.ErrorColor
                elseif data.type == "Warning" then
                    entry.BackgroundColor3 = theme.WarningColor
                else
                    entry.BackgroundColor3 = theme.LightContrast
                end
            end
        end
    end
    
    -- Enhanced UI Components
    function self:CreateStylizedButton(parent, text, callback)
        local button = Instance.new("TextButton")
        button.Size = UDim2.new(0, 100, 0, 30)
        button.BackgroundColor3 = self.Settings.theme.AccentColor
        button.TextColor3 = self.Settings.theme.TextColor
        button.Text = text
        button.Font = Enum.Font.Gotham
        button.TextSize = 14
        button.AutoButtonColor = true
        
        -- Rounded corners
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 6)
        corner.Parent = button
        
        -- Hover effect
        local hoverFrame = Instance.new("Frame")
        hoverFrame.BackgroundColor3 = Color3.new(1, 1, 1)
        hoverFrame.BackgroundTransparency = 1
        hoverFrame.Size = UDim2.new(1, 0, 1, 0)
        hoverFrame.Parent = button
        
        local corner2 = Instance.new("UICorner")
        corner2.CornerRadius = UDim.new(0, 6)
        corner2.Parent = hoverFrame
        
        button.MouseEnter:Connect(function()
            game:GetService("TweenService"):Create(hoverFrame, 
                TweenInfo.new(0.2), 
                {BackgroundTransparency = 0.9}
            ):Play()
        end)
        
        button.MouseLeave:Connect(function()
            game:GetService("TweenService"):Create(hoverFrame, 
                TweenInfo.new(0.2), 
                {BackgroundTransparency = 1}
            ):Play()
        end)
        
        button.MouseButton1Click:Connect(callback)
        button.Parent = parent
        
        return button
    end
    
    function self:CreateSearchBar(parent)
        local searchContainer = Instance.new("Frame")
        searchContainer.Size = UDim2.new(0, 200, 0, 30)
        searchContainer.BackgroundColor3 = self.Settings.theme.LightContrast
        searchContainer.Parent = parent
        
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 6)
        corner.Parent = searchContainer
        
        local searchBox = Instance.new("TextBox")
        searchBox.Size = UDim2.new(1, -30, 1, 0)
        searchBox.Position = UDim2.new(0, 30, 0, 0)
        searchBox.BackgroundTransparency = 1
        searchBox.TextColor3 = self.Settings.theme.TextColor
        searchBox.PlaceholderText = "Search..."
        searchBox.PlaceholderColor3 = self.Settings.theme.TextColor:Lerp(self.Settings.theme.Background, 0.5)
        searchBox.Font = Enum.Font.Gotham
        searchBox.TextSize = 14
        searchBox.Parent = searchContainer
        
        local searchIcon = Instance.new("ImageLabel")
        searchIcon.Size = UDim2.new(0, 16, 0, 16)
        searchIcon.Position = UDim2.new(0, 8, 0.5, -8)
        searchIcon.BackgroundTransparency = 1
        searchIcon.Image = "rbxassetid://3605509925"
        searchIcon.ImageColor3 = self.Settings.theme.TextColor
        searchIcon.Parent = searchContainer
        
        return searchBox
    end
end

-- Additional Features
function UILibrary:AddFeatures()
    -- Remote Call History
    self.CallHistory = {}
    
    function self:AddToHistory(remote, args, result)
        table.insert(self.CallHistory, {
            remote = remote,
            args = args,
            result = result,
            timestamp = os.time()
        })
        
        -- Limit history size
        if #self.CallHistory > self.Settings.maxLogs then
            table.remove(self.CallHistory, 1)
        end
    end
    
    function self:ShowCallHistory()
        local HistoryFrame = Instance.new("Frame")
        HistoryFrame.Size = UDim2.new(0, 400, 0, 300)
        HistoryFrame.Position = UDim2.new(0.5, -200, 0.5, -150)
        HistoryFrame.BackgroundColor3 = self.Settings.theme.Background
        HistoryFrame.BorderSizePixel = 0
        
        local HistoryList = Instance.new("ScrollingFrame")
        HistoryList.Size = UDim2.new(1, -20, 1, -60)
        HistoryList.Position = UDim2.new(0, 10, 0, 50)
        HistoryList.BackgroundTransparency = 1
        HistoryList.Parent = HistoryFrame
        
        -- Add history entries
        local yPos = 0
        for _, entry in ipairs(self.CallHistory) do
            local entryFrame = Instance.new("Frame")
            entryFrame.Size = UDim2.new(1, 0, 0, 60)
            entryFrame.Position = UDim2.new(0, 0, 0, yPos)
            entryFrame.BackgroundColor3 = self.Settings.theme.LightContrast
            entryFrame.Parent = HistoryList
            
            -- Add entry details...
            yPos = yPos + 70
        end
        
        return HistoryFrame
    end
    
    -- Remote Statistics
    self.Statistics = {
        calls = {},
        totalCalls = 0,
        averageTimes = {}
    }
    
    function self:UpdateStatistics(remote, duration)
        if not self.Statistics.calls[remote] then
            self.Statistics.calls[remote] = 0
            self.Statistics.averageTimes[remote] = 0
        end
        
        self.Statistics.calls[remote] = self.Statistics.calls[remote] + 1
        self.Statistics.totalCalls = self.Statistics.totalCalls + 1
        
        -- Update average time
        local prev = self.Statistics.averageTimes[remote]
        local count = self.Statistics.calls[remote]
        self.Statistics.averageTimes[remote] = (prev * (count - 1) + duration) / count
    end
    
    function self:ShowStatistics()
        local StatsFrame = Instance.new("Frame")
        StatsFrame.Size = UDim2.new(0, 300, 0, 400)
        StatsFrame.Position = UDim2.new(1, -320, 0, 20)
        StatsFrame.BackgroundColor3 = self.Settings.theme.Background
        StatsFrame.BorderSizePixel = 0
        
        -- Add statistics displays...
        
        return StatsFrame
    end
    
    -- Remote Favorites
    self.Favorites = {}
    
    function self:ToggleFavorite(remote)
        self.Favorites[remote] = not self.Favorites[remote]
        self:SaveSettings() -- Save favorites with settings
    end
    
    function self:ShowFavorites()
        local FavFrame = Instance.new("Frame")
        FavFrame.Size = UDim2.new(0, 200, 0, 300)
        FavFrame.Position = UDim2.new(0, 20, 0, 20)
        FavFrame.BackgroundColor3 = self.Settings.theme.Background
        FavFrame.BorderSizePixel = 0
        
        -- Add favorites list...
        
        return FavFrame
    end
    
    -- Remote Groups
    self.Groups = {}
    
    function self:CreateGroup(name)
        self.Groups[name] = {}
    end
    
    function self:AddToGroup(groupName, remote)
        if self.Groups[groupName] then
            table.insert(self.Groups[groupName], remote)
        end
    end
    
    -- Code Generation
    function self:GenerateCode(remote, args)
        local code = string.format("local remote = game:GetService(\"ReplicatedStorage\"):WaitForChild(\"%s\")\n", remote)
        
        if #args > 0 then
            code = code .. "local args = {\n"
            for i, arg in ipairs(args) do
                code = code .. string.format("    [%d] = %s,\n", i, self:ValueToString(arg))
            end
            code = code .. "}\n"
            code = code .. "remote:FireServer(unpack(args))"
        else
            code = code .. "remote:FireServer()"
        end
        
        return code
    end
    
    function self:ValueToString(value)
        if type(value) == "string" then
            return string.format("\"%s\"", value)
        elseif type(value) == "table" then
            local result = "{\n"
            for k, v in pairs(value) do
                result = result .. string.format("    [%s] = %s,\n", 
                    self:ValueToString(k), self:ValueToString(v))
            end
            return result .. "}"
        else
            return tostring(value)
        end
    end
end
-- Optimization
function UILibrary:Optimize()
    -- Cache frequently used services
    local TweenService = game:GetService("TweenService")
    local RunService = game:GetService("RunService")
    
    -- Debounce system
    self.Debounces = {}
    
    function self:Debounce(key, func, wait)
        wait = wait or 0.1
        if self.Debounces[key] then return end
        
        self.Debounces[key] = true
        func()
        
        task.delay(wait, function()
            self.Debounces[key] = nil
        end)
    end
    
    -- Object pooling for UI elements
    self.ObjectPool = {
        pool = {},
        active = {}
    }
    
    function self:CreatePool(className, initialSize)
        self.ObjectPool.pool[className] = {}
        
        for i = 1, initialSize do
            local obj = Instance.new(className)
            obj.Parent = nil
            table.insert(self.ObjectPool.pool[className], obj)
        end
    end
    
    function self:GetFromPool(className)
        if not self.ObjectPool.pool[className] then
            self:CreatePool(className, 10)
        end
        
        local obj = table.remove(self.ObjectPool.pool[className])
        if not obj then
            obj = Instance.new(className)
        end
        
        self.ObjectPool.active[obj] = true
        return obj
    end
    
    function self:ReturnToPool(obj)
        if self.ObjectPool.active[obj] then
            obj.Parent = nil
            table.insert(self.ObjectPool.pool[obj.ClassName], obj)
            self.ObjectPool.active[obj] = nil
        end
    end
    
    -- Frame rate optimization
    self.UpdateQueue = {}
    self.IsUpdating = false
    
    function self:QueueUpdate(func)
        table.insert(self.UpdateQueue, func)
        
        if not self.IsUpdating then
            self.IsUpdating = true
            
            RunService.Heartbeat:Connect(function()
                if #self.UpdateQueue > 0 then
                    local nextUpdate = table.remove(self.UpdateQueue, 1)
                    nextUpdate()
                else
                    self.IsUpdating = false
                end
            end)
        end
    end
    
    -- Memory management
    function self:CleanupInstance(instance)
        for _, connection in pairs(getconnections(instance)) do
            connection:Disconnect()
        end
        
        for _, child in ipairs(instance:GetChildren()) do
            self:CleanupInstance(child)
        end
        
        instance:Destroy()
    end
    
    -- Batch processing
    function self:BatchProcess(items, processor, batchSize)
        batchSize = batchSize or 10
        local results = {}
        
        for i = 1, #items, batchSize do
            local batch = {}
            for j = i, math.min(i + batchSize - 1, #items) do
                table.insert(batch, items[j])
            end
            
            self:QueueUpdate(function()
                for _, item in ipairs(batch) do
                    table.insert(results, processor(item))
                end
            end)
        end
        
        return results
    end
end

-- Error Handling
function UILibrary:EnhanceErrorHandling()
    -- Error types
    self.ErrorTypes = {
        REMOTE_NOT_FOUND = "Remote object not found",
        INVALID_ARGUMENTS = "Invalid arguments provided",
        NETWORK_ERROR = "Network communication error",
        PERMISSION_DENIED = "Permission denied",
        RATE_LIMITED = "Rate limit exceeded",
        INTERNAL_ERROR = "Internal error occurred"
    }
    
    -- Error handler
    function self:HandleError(errorType, context, optional)
        local errorInfo = {
            type = errorType,
            context = context,
            timestamp = os.time(),
            optional = optional
        }
        
        -- Log error
        self:Log({
            type = "Error",
            message = string.format("[%s] %s", errorType, context),
            details = optional
        })
        
        -- Update UI to show error
        if self.ErrorDisplay then
            self:UpdateErrorDisplay(errorInfo)
        end
        
        -- Error recovery
        self:AttemptErrorRecovery(errorInfo)
        
        return errorInfo
    end
    
    -- Error recovery
    function self:AttemptErrorRecovery(errorInfo)
        if errorInfo.type == self.ErrorTypes.REMOTE_NOT_FOUND then
            -- Attempt to relocate remote
            self:QueueUpdate(function()
                self:RescanRemotes()
            end)
        elseif errorInfo.type == self.ErrorTypes.NETWORK_ERROR then
            -- Implement retry mechanism
            self:RetryOperation(errorInfo.context)
        elseif errorInfo.type == self.ErrorTypes.RATE_LIMITED then
            -- Add to delayed queue
            self:AddToDelayedQueue(errorInfo.context)
        end
    end
    
    -- Retry mechanism
    self.RetryQueue = {}
    
    function self:RetryOperation(operation, maxRetries)
        maxRetries = maxRetries or 3
        local retryCount = 0
        
        local function attempt()
            if retryCount >= maxRetries then
                self:HandleError(self.ErrorTypes.INTERNAL_ERROR, "Max retries exceeded")
                return
            end
            
            retryCount = retryCount + 1
            
            local success, result = pcall(function()
                return operation()
            end)
            
            if not success then
                wait(math.pow(2, retryCount)) -- Exponential backoff
                attempt()
            else
                return result
            end
        end
        
        return attempt()
    end
    
    -- Rate limiting
    self.RateLimits = {}
    
    function self:CheckRateLimit(key, limit, window)
        if not self.RateLimits[key] then
            self.RateLimits[key] = {
                count = 0,
                resetTime = os.time() + window
            }
        end
        
        if os.time() >= self.RateLimits[key].resetTime then
            self.RateLimits[key].count = 0
            self.RateLimits[key].resetTime = os.time() + window
        end
        
        if self.RateLimits[key].count >= limit then
            return false
        end
        
        self.RateLimits[key].count = self.RateLimits[key].count + 1
        return true
    end
end

-- Cleanup
function UILibrary:Cleanup()
    -- Disconnect all events
    for _, connection in pairs(self.Connections) do
        if typeof(connection) == "RBXScriptConnection" then
            connection:Disconnect()
        end
    end
    
    -- Clear object pools
    for className, pool in pairs(self.ObjectPool.pool) do
        for _, obj in ipairs(pool) do
            obj:Destroy()
        end
    end
    
    for obj, _ in pairs(self.ObjectPool.active) do
        obj:Destroy()
    end
    
    -- Clear queues
    self.UpdateQueue = {}
    self.RetryQueue = {}
    self.RateLimits = {}
    
    -- Remove UI elements
    if self.GUI then
        self:CleanupInstance(self.GUI)
    end
    
    -- Clear data
    self.RemotesList = {}
    self.CallHistory = {}
    self.Statistics = {
        calls = {},
        totalCalls = 0,
        averageTimes = {}
    }
    
    -- Reset state
    self.IsUpdating = false
    self.Debounces = {}
    
    -- Clear references
    self = nil
end
